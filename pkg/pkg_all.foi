package_info frt =
  let Println: string->()
  let Sprintf1<T>: string->T->string
  let Printf1<T>: string->T->()
  let Fst<T, U> : T*U->T
  let Snd<T, U> : T*U->U
  let Assert : bool->string->()
  let Panic : string->()
  let Panicf1<T>: string->T->()


package_info buf =
  type Buffer
  let New: ()->Buffer
  let Write: Buffer->string->()
  let String: Buffer->string

package_info slice =
  let Length<T>: []T -> int
  let IsEmpty<T>: []T -> bool
  let Last<T>: []T -> T
  let Head<T>: []T -> T
  let Tail<T>: []T -> []T
  let PopLast<T>: []T -> []T
  let PushLast<T>: T->[]T->[]T
  let PushHead<T>: T->[]T->[]T
  let Collect<T, U>: (T->[]U)->[]T->[]U
  let Concat<T>: [][]T->[]T
  let Append<T>: []T->[]T->[]T
  let Take<T> : int->[]T->[]T
  let Map<T, U> : (T->U)->[]T->[]U
  let Mapi<T, U> : (int->T->U)->[]T->[]U
  let Iter<T> : (T->())->[]T->()
  let Filter<T> : (T->bool)->[]T->[]T
  let Sort<T>: []T -> []T
  let SortBy<T, U>: (T->U)->[]T->[]T
  let Skip<T>: int->[]T->[]T
  let Zip<T, U>: []T->[]U->[]T*U
  let Forall<T>: (T->bool)->[]T->bool
  let Forany<T>: (T->bool)->[]T->bool
  // T must be comparable
  let Distinct<T>: []T->[]T

package_info strings =
  let Concat: string->[]string->string
  let Length: string->int
  let AppendTail: string->string->string
  let HasSuffix: string->string->bool
  let TrimSuffix: string->string->string
package_info sys =
  let Args: ()->[]string
  let ReadFile: string->string*bool
  let WriteFile: string->string->bool

