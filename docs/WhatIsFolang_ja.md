# Folangとは何か？

FolangはF#やReScriptに似た関数型言語のGolangへのトランスパイラです。

F#がOCamlを.NET向けにしたもの、ReScriptがOCamlをJavaScript向けにしたもの、
とするなら、FolangはOCamlをGolang向けにしたもの、を目指しています。
ただしシンタックスはOCamlよりもF#に強く影響を受けています。

[サンプルのページ](../samples/README.md)を見ると、雰囲気は伝わると思います。

FolangはFolangでセルフホストされている為、
Golangのみで試す事が出来ます。OCamlや.NETの環境が必要無いのは大きなメリットです。

またトランスパイル後は通常のGoファイルとなる為、
単にそのファイルをgithubに置くだけで通常のGoのモジュールシステムに乗る事が出来ます。

以下、それぞれについてもう少し詳しく述べてみます。

## 生成したデータ型や関数の型が、Goとして自然

以下のFolangのコードは

```fsharp
let a = 3
```

以下のGoコードにトランスパイルされます。

```golang
a := 3
```

以下のレコード型は

```fsharp
type Rec = {A: int; B: string}
```

以下のstructに展開されます。

```golang
type Rec struct {
  A int
  B string
}
```

以下の関数は

```fsharp
let add3 (a:int) =
  a + 3
```

以下のGoコードに変換されます。

```golang
func add3(a int) int {
  return a+3
}
```

if elseなどは式になる都合で関数でラップされる醜いコードになってしまいますが、
生成された関数を呼ぶのもデータ型を使うのも、
特別なことが必要無い、というのは重視した所です。

生成されたコードは、読みやすいとは言いませんが、
少なくともデバッガでデバッグ可能なくらいではあります。

## 生成したあとは単なるGoファイルである

トランスパイラなので、生成した結果はGoのソースファイルとなります。

トランスパイルするコマンドはfcといいますが、一度トランスパイルすれば以後はfcは必要ありません。
ランタイムとして使うのも通常のGoのパッケーのの一種、github.com/karino2/folang/pkg/frt にあるGoモジュールで、
その他のパッケージを使うのと変わりません。

結果として生成したあとはGoモジュールとして使う事が出来ますし、
githubに置けばgo getやgo installすることも出来ます。

それはどういうpackageにしてどういうmodにするのか、
というGo言語の側での問題であってFolangは関係ありません。
そしてGoはこのパッケージやデプロイの仕組みが非常に優れた言語です。

また、シングルバイナリでどの環境でも簡単にセットアップ出来て、
立ち上がりも早い。
Goのシングルバイナリは本当に素晴らしい！

ツールを書くのに優れたこれらのGo言語の特性は全て引き継がれます。

ただし実行速度に関しては生成するコードが無駄に関数が多いコードなので、
手でGolangを書く事に比べてだいぶ遅いと思います。
Folangはパフォーマンスはあまり良くない言語と思います（測っていませんが）。

## Go以外の環境が必要無い

FolangのトランスパイラはFolangで書かれている為、
生成されたGoコードを実行するGo環境しか必要ありません。
OCamlやHaskellなどの環境をセットアップしなくて良い、
というのは、大きなメリットと思っています。

Goは多くの環境で良く整備されていてセットアップも詰まらず、
生成されるバイナリもいろいろな環境でトラブル無く動きます。

そしてGoの開発環境は、プログラマの多くがどちらにせよセットアップするので、
最初からすでに手元にある事が多いでしょう。

一つのマシンで作ったら他のマシンに容易に展開出来るのが、
雑用のツールをGolangで作る大きなメリットと思います。

## 想定する用途は小規模ツール

Folangの主なターゲットは100行〜5000行くらいの規模のコマンドラインツールです。
このドキュメント執筆時点では一番大きなFolangプログラムはFolangのトランスパイラ自身である[fc](../fc)で、
これは現時点では3612行のFoコードと529行のGoコードで出来ています。
大きくてもだいたいこのくらいの規模を想定しています。
もっと大きな規模のものを作りたい人は他の言語を選ぶ方が良いでしょう。

扱うデータもあまり大きなものを効率良く扱うように、とは考えていません。
実行時のパフォーマンスもあまり気にしていません。
これらの特性も、あまり大きなツールやwebサービスを作るのには向いているとは思えない所です。

ただし小さなプログラムの立ち上がりは早い事を重視しています。
特にその為に何かをしている訳ではありませんが、Goは立ち上がりが早くて素晴らしいですね。

自分としては普段F#やPythonで書いている日常的なツールを置き換えるために作りました。

## なぜOCaml系の言語なのか

ここまで挙げたメリットはほとんどが「Go言語は素晴らしい」と言っているだけで、
Folangのメリットは特にありません。
実際好みの問題でGoの方が好き、という人も多いでしょう。

以下では自分がOCaml系の言語を欲しいと思った理由を書いておきますが、
単に自分の好みだ、というだけでもあります。

Go言語は見た通りに動く事が重視されていて、
見えない所で勝手にコストが掛かるような事をしない、
という言語デザインがされていると思います。
これは非常に優れた特徴でもあり、
システムプログラムにおいて、とてもうまく機能するのがGo言語がここまで広まった理由だとも思います。

ですが自分の用途である小さなツールなどを書くには、
別に見えない所でコストが掛かってもあまり気にしません。
小さくて立ち上がりの早いシングルバイナリやmodシステム、パッケージの出来の良さ、
環境設定周りの良く出来ている度合いなどからGolangを選択する事がありますが、
ここまで低レベルである必要は全く無い。

それよりも簡潔に書ける方が嬉しい。
特に型推論とパイプ演算子と部分適用で簡潔に書けるのが小さなツールを書くには嬉しい。

遅くてもいいから短くて簡潔に書ける言語なら、
Go言語以外を選べばいろいろ候補があります。
ですが、そういった言語はコードサイズが少し大きくなって数千行くらいで意外ときつくなってしまうものが多い。

自分としては最初は簡潔に小さく始められるが、
ちょっとだけ複雑になった時にDiscriminated Unionによる強力な型のモデリング機能を使いたい。
こうした要望と高水準で遅くても良い代わりに簡潔な言語、というのを求めていました。

また、基本的な機能だけでもある程度コードが書ける言語が、
トランスパイラを個人で実装する立場からすると望ましい。
kotlinのようにインラインのreturnなど複雑なものまで揃えてからでないと便利に使えないような言語は、
実装するのは厳しい。
使い始めるのに最小限の機能だけでもなんとかやれそうな言語が望ましい。

それとReScriptのようなトランスパイラとしての実績があるのも、
実現方法に悩んだ時に参考にするのに良いと思いました。

最後に自分がF# に慣れていて気に入っていたので、
それと似た言語と考えています。

## Goに開かれたトランスパイラ

生成されるGoコードが型や関数としてプレーンな事は先にも述べました。

そのほかにも、Folangは最初から言語として必要なものを全て含める事は目指さず、
足りない部分はGolangで書く前提の言語です。
その代わりFolangの言語仕様はシンプルに保ち、
Golangのコードとやり取りするのは簡単になるように設計されています。

特に1000行以上のコードの場合は、Goで向いている部分はGoで書くように分業するのが推奨されるスタイルです。

例えばFolangのトランスパイラであるfcは、この文書執筆時点では、
3612行のFoコードと529行のGoコードで出来ています。
これは典型的なFolangの構成で、
無理にループや破壊的代入、ポインタなどのシンタックスを入れるのでは無くて、
そういうものはGoで書く、という考えで居ます。

これは必須ではありませんが、wrapper.goというファイルを作り、
この中にFolang向けにフリースタンディング関数でパイプライン向けに引数を調整した関数を作り、
それを必要に応じて書いて呼んでいく、というスタイルをイディオムとしています。

オニオンアーキテクチャの中側をFolangで書き、
外側をGolangで書くようなイメージです。
Goのパッケージをそのまま呼ぶのでは無くて、
問題に合わせてラッパーを書いてそれ用のインターフェース情報を手書きする、
それが簡単に出来るように設計されています。

また、最初からGoと分業する事を前提とする為、
Folangで未実装だったり足りない機能があっても、
Goの側で実装する事がいつでも可能です。
そのため、Folangの完成を待つ事無く、今ある機能で使っていく事が出来ます。

このGo言語に開かれた言語を目指すために、既存の言語のバックエンドをGolang向けにするのでは無く、
Goに向けて独自の言語を作る、という選択をする事にしました。

## Go言語を生成するためのツール

完全に独自の言語だけで全てをやるのでは無く、
Goを生成するためのツール、くらいのつもりで使うと便利に使えます。

実際目的のコードが生成されさえすれば良いので、
一部ではインターフェース定義に嘘をついたりも出来ますし、
GoEvalなどの機能を使ってGo言語に向けた穴を作ったりも出来ます。

例えば以下のようにSprintfを2引数の関数と嘘をつく事も出来ますし、

```
import "fmt"

package_info fmt =
  let Sprintf<T>: string->T->string

let Sprintf1 fmt arg =
  fmt.Sprintf fmt arg

```

以下のように3引数の関数と嘘をついても構いません。

```
package_info fmt =
  let Sprintf<T, U>: string->T->U->string

let Sprintf2 msg arg1 arg2 =
  fmt.Sprintf msg arg1 arg2
```

Folangの中で型が一貫していて、
生成されるGolangはGolangの中で正当なコードであれば、
それで良いのです。

閉じた世界と考えるのでは無く、エディタの延長としてGoコードを生成する何か、
くらいに考える方が実態に近いと思います。