# 3. スライスとパイプとMap

前回: [2. frtパッケージを使う (pkg_all.foiの説明)](2_UseFrtPackage_ja.md)

Folangでもgolangと同様、スライスは中心となるデータ構造です。
Folangのスライスは内部的にはgolangそのままですが、
シンタックスなどに多少の違いがあります。

また、スライスの扱い方はより関数型言語的に扱う事が普通で、
Mapやパイプラインはその典型的なものとなります。

## スライスの作り方とlet

スライスは以下のようにセミコロンで区切って作ります。

```
let main () =
  let s = [1; 2; 3]
  frt.Printf1 "%v\n" s
```

スライスの他に新しい要素が幾つか出ています。

1. letで変数を定義する
2. Printf1というもので追加引数一つのgolangで言うPrintfのようなものがある
3. スライスのリテラルは大括弧で囲んで間はセミコロン（カンマでは無い！）

ちなみに生成されるコードは以下です。

```golang
func main() {
	s := ([]int{1, 2, 3})
	frt.Printf1("%v\n", s)
}
```

`let s =` は `s :=` にトランスパイルされます。

`%v` などは通常のgolangと同様です。

## Mapとstrings.Concatとパイプ演算子

次は少し複雑な例を見てみます。

```
package main
import frt

// 以下二行追加
import slice
import strings

let main () =
  [1; 2; 3]
  |> slice.Map (frt.Sprintf1 "This is %d")
  |> strings.Concat ", "
  |> frt.Println
```

実行すると以下のように表示されます。

```
This is 1, This is 2, This is 3
```

### F#知っている人向けの解説

これは F# に詳しい人ならほぼそのまま読む事が出来ると思いますが、
まずは F# を知っている人向けに、違いを幾つか説明しておきます。

- パッケージ名は小文字始まりで関数名は大文字始まり(.NETの規約と違いgolangの規約になっている)
- slice.XXXはだいたいはList.XXX と同じAPIになっている

このくらい分かればF# の人は十分でしょう。

FolangはF# の.NETっぽい部分をgolangっぽく差し替えた言語、
と思えば9割くらい正しい理解となります。

### パイプ演算子(F#知らない人向け)

以下はF# を知らない人向けにコードを簡単に解説していきます。

ただこのチュートリアルでは、あまり細部にはこだわらずに動かしてみるのを優先していくので、
解説は少なめに進めたいと思います。

まず以下の二行がなかなか難解です。

```fsharp
  [1; 2; 3]
  |> slice.Map (frt.Sprintf1 "This is %d")
```

まず `|>` はパイプ演算子と言われるもので、`+` とかと同様二項演算子です。
やる事は左の要素を右の関数の引数として呼び出す、という事になります。

パイプ演算子は初めて見る人には非常に分かりにくいけれど、
使っているとすぐに慣れるものなので、
解説はふんわりと理解したくらいで先に進むのがおすすめです。

パイプ演算子は左の要素を右の関数にわたすので、

1. パイプ演算子の左は要素である
2. パイプ演算子の右は、1引数の関数である

という２つの条件が必要です。この二点に注意しつつ以下の説明を読んでみてください。

### 部分適用による関数の合成

さて、以下のコードで

```fsharp
  |> slice.Map (frt.Sprintf1 "This is %d")
```

パイプ演算子の次はslice.Mapの説明…と行きたい所ですが、
その前にその先の `(frt.Sprintf1 "This is %d")` というのが難しい所になります。

Sprintf1は、名前から予想出来るように追加の引数を一つとるSprintfのようなものです。
ですから、本来は以下のように使います。

```fsharp
frt.Sprintf1 "This is %d" 123 //<- この最後の123に注目
```

このように、文字列のあとに123という引数があるのが普通の使い方です。

では123が無い、つまり引数が一つ足りない場合はどうなるのでしょう？

```fsharp
let f1 = frt.Sprintf1 "This is %d"
f1 123
```

これは部分適用といって、残りの引数が一つある関数（この場合は`func[T any](arg T) string` の関数のような感じに解釈される）となります。
実際このコードをトランスパイルすると以下のようなコードになります。

```golang
f1 := (func (_r0 int) string{
        return frt.Sprintf1("This is %d", _r0)
      })
f1(123)
```

`_r0`の型がintになるのは話すと長くなるのでそういうものと思ってください。
なお、`%d`をちゃんと見たりしている訳ではありません（今の所そこまで賢くは無い）。

とにかくfolangでは、関数に引数の数が足りない時には、その足りない引数を持つfuncのようなものとして新しい関数オブジェクトが生成されます。
これを部分適用といいます。

ここで重要なのは、 `frt.Sprinf1 "This is %d"` が、`func(int)string`という関数になっている、という事です。

### slice.Map

sliceパッケージもほぼ全てのfolangプログラムで使うものです。
特に `slice.Map` は頻出。

slice.Mapは以下のように２つの引数を取ります。

`slice.Map fn slice1`

２つ目の引数がスライスで、その要素一つ一つに順番にfnを実行して、結果をまたスライスにまとめて返します。

```fsharp

let add10 a =
   a+10

let main () =
  let res = slice.Map add10 [1; 2; 3]
  frt.Printf1 "%v\n" res

```

これで以下のように表示されます。

```
[11 12 13]
```

これがMapです。

### パイプ演算子で書き換える

さて、以下の行は、

```fsharp
  let res = slice.Map add10 [1; 2; 3]
```

パイプ演算子を使って最後の要素を前に持ってくる事が出来ます。

```fsharp
let res = [1; 2; 3] |> slice.Map add10 
```

全体だと見づらいですが、以下の部分だけ取り出すと、

```fsharp
slice.Map add10 [1; 2; 3]
```

この最後の要素を左に持ってきて、以下のように書ける訳です。

```fsharp
[1; 2; 3] |> slice.Map add10 
```

両者は同じ結果になります。

これを踏まえると以下のコードもだいたい分かるのでは無いでしょうか？

```fsharp
  [1; 2; 3]
  |> slice.Map (frt.Sprintf1 "This is %d")
  |> strings.Concat ", "
  |> frt.Println
```

なお、strings.Concatも少し特殊です。
これは文字列のスライスを受け取り、それを間に引数を挟んでつなげた文字列を返す、
という関数です。つまり`[]string`を受けとり、つなげた`string`を返す訳です。

このMapでいろいろ加工して最後にstrings.Concatを呼ぶのはFolangの文字列処理の基本になるイディオムです。

