package main

import frt
import slice

// wrapper types.
package_info _ =
  type Scope
  let NewScope: ()->Scope
  let scDefVar: Scope->string->Var->()
  let scLookupVarFac: Scope->string->(()->Var)*bool
  let scRegisterRecType: Scope->RecordType->()
  let scLookupRecord: Scope->[]string->RecordType*bool


type ParseState = {
  tkz: Tokenizer;
  scope: Scope;
  // offsideCol: []int;
  // typeDefCtx
}


// wrapper types. Use ParseState
package_info _ =
  let withPs<T>: ParseState->T->ParseState*T
  // inference from funcall to arg side is NYI.
  // let CnvL<T, U>: (T->T)->T*U->T*U
  // let CnvR<T, U>: (U->U)->T*U->T*U
  let CnvL<U>: (ParseState->ParseState)->ParseState*U->ParseState*U
  let CnvR<U>: (U->U)->T*U->T*U


let newParse (tkz:Tokenizer) (scope:Scope) =
  {tkz=tkz; scope=scope}

let psWithTkz (org:ParseState) (tkz:Tokenizer) =
  {tkz=tkz; scope=org.scope}

let psWithScope (org:ParseState) (nsc:Scope) =
  {tkz=org.tkz; scope=nsc}


let initParse (src: string) =
  let tkz = newTkz src
  let scope = NewScope ()
  newParse tkz scope

let psCurrent (ps:ParseState) =
  ps.tkz.current

let psCurrentTT (ps:ParseState) =
  let tk = psCurrent ps
  tk.ttype

let psNext (ps:ParseState) =
  let ntk = tkzNext ps.tkz
  psWithTkz ps ntk

let psNextNOL (ps:ParseState) =
  let ntk = tkzNextNOL ps.tkz
  psWithTkz ps ntk

let psSkipEOL (ps:ParseState) =
  if (psCurrentTT ps) = EOL then
    psNextNOL ps
  else
    ps


let psExpect (ttype:TokenType) (ps:ParseState) =
  let cur = psCurrent ps
  if cur.ttype <> ttype then
    frt.Panic("non expected token")
  ()

let psConsume (ttype:TokenType) (ps:ParseState) =
  psExpect ttype ps
  psNext ps


let psIdentName (ps:ParseState) =
  psExpect IDENTIFIER ps
  let cur = psCurrent ps
  cur.stringVal

let psStringVal (ps:ParseState) =
  psExpect STRING ps
  let cur = psCurrent ps
  cur.stringVal


let parsePackage (ps:ParseState) =
  let ps2 = psConsume PACKAGE ps
  let pname = psIdentName ps2
  let ps3 = psNextNOL ps2
  let pkg = Package pname
  (ps3, pkg)

let parseImport (ps:ParseState) =
  let ps2 = psConsume IMPORT ps
  let pname = psStringVal ps2
  let ps3 = psNextNOL ps2
  let imp = Import pname
  (ps3, imp)


/*
TYPE = ATOM_TYPE

ATOM_TYPE = 'string' | 'int' | '(' ')'

TODO:
ATOM_TYPE = 'string' | 'int' | '(' ')' | REGISTERED_TYPE | '[' ']' TYPE
*/
let parseType (ps:ParseState) =
  let tk = psCurrent ps
  match tk.ttype with
  | LPAREN ->
    let ps2 = ps |> psConsume LPAREN |> psConsume RPAREN
    (ps2, FUnit)
  | IDENTIFIER ->
    let tname = tk.stringVal
    let ps3 = psNext ps
    let rtype = if tname = "string" then
                  FString
                elif tname = "int" then
                  FInt
                elif tname = "bool" then
                  FBool
                else
                  frt.Panic("NYI")
                  FUnit
    (ps3, rtype)
  | _ ->
    frt.Panic("Unknown type")
    (ps, FUnit)


type Param =
| PVar of Var
| PUnit

/*
	PARAM = '(' ')'
				|	'(' IDENTIFIER : TYPE ')'

*/
let parseParam (ps:ParseState) =
  let ps2 = psConsume LPAREN ps
  let tk = psCurrent ps2
  match tk.ttype with
  | RPAREN ->
     let ps3 = psConsume RPAREN ps2
     (ps3, PUnit)
  | _ ->
    let vname = psIdentName ps2
    let ps3 = psNext ps2 |> psConsume COLON
    let (ps4, tp) = parseType ps3
    let ps5 = psConsume RPAREN ps4
    let v = {Var.name=vname; ftype=tp}
    // TODO: define var to scope here.
    (ps5, (PVar v))

let parseParams (ps:ParseState) : ParseState*[]Var =
  let (ps2, prm1) = parseParam ps
  match prm1 with
  | PUnit ->
      let zero = GoEval<[]Var> "[]Var{}"
      (ps2, zero)
  | PVar v ->
      let tt = psCurrentTT ps2
      match tt with
      | LPAREN ->
        let ftp2 = parseParams ps2
        let ps3 = frt.Fst ftp2
        let prms2 = frt.Snd ftp2
        let pas3 = slice.Append v prms2
        (ps3, pas3)
      | _ -> (ps2, [v])

let parseGoEval (ps:ParseState) =
  let ps2 = psNext ps // consume "GoEval"
  let cur = psCurrent ps2
  let ge = {goStmt=cur.stringVal; typeArg=FUnit}
  let ps3 = psNext ps2
  (ps3, GoEvalExpr ge)


// FIELD_INITIALIZER = IDENTIFIER '=' expr
let parseFiIni (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let fname = psIdentName ps
  let (ps2, expr) = psNextNOL ps |> psConsume EQ |> psSkipEOL |> parseE
  (ps2, {name=fname;expr=expr})


let parseFieldInitializers (parseE: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]NEPair =
  let (ps2, nep) = parseFiIni parseE ps
  if (psCurrentTT ps2) = RBRACE then
    (ps2, [nep])
  else
    let (ps3, rest) = psConsume SEMICOLON ps2 |> parseFieldInitializers parseE
    slice.Prepend nep rest |> withPs ps3

let NVPToName (nvp:NEPair) =
  nvp.name

/*
RECORD_EXPRESISONN = '{' FIELD_INITIALIZERS '}'

FIELD_INITIALIZERS = FIELD_INITIALIZER (';' FIELD_INITIALIZER)*

FIELD_INITIALIZER = IDENTIFIER '=' expr
*/
let parseRecordGen (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, neps) = psConsume LBRACE ps |> parseFieldInitializers parseE |> CnvL (psConsume RBRACE)
  let (rtype, ok) = slice.Map NVPToName neps |> scLookupRecord ps2.scope
  if ok then
    {fieldsNV=neps; recordType=rtype}
    |> RecordGen |> withPs ps2
  else
    frt.Panic "record field name match to no record type."
    (ps2, Unit)

let parseAtom (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let cur = psCurrent ps
  let pn = psNext ps
  match cur.ttype with
  | STRING ->
    StringLiteral cur.stringVal |> withPs pn
  | INT_IMM ->
    IntImm cur.intVal |> withPs pn
  | LBRACE ->
    parseRecordGen parseE ps
  | IDENTIFIER ->
    if cur.stringVal = "GoEval" then
      parseGoEval ps
    else
      let (vfac, ok) = scLookupVarFac ps.scope cur.stringVal
      if ok then
        vfac () |> Var |> withPs pn
      else
        frt.Panic "Unkonw var ref"
        (ps, Unit)
  | _ -> (ps, Unit)


let isEndOfTerm (ps:ParseState) =
  match psCurrentTT ps with
  | EOF -> true
  | EOL -> true
  | SEMICOLON -> true
  | RBRACE -> true
  | _ -> false

let parseAtomList (parseE: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]Expr =
  let (ps2, one) = parseAtom parseE ps
  if isEndOfTerm ps2 then
    (ps2, [one])
  else
    let (ps3, rest) = parseAtomList parseE ps2
    let al = slice.Prepend one rest
    (ps3, al)

let parseTerm (ps:ParseState) : Expr =
  let (ps2, es) = parseAtomList parseTerm ps
  if (slice.Length es) = 1 then
    (ps2, (slice.Head es))
  else
    // funcall
    let head = slice.Head es
    let tail = slice.Tail es
    match head with
    | Var v ->
      let fc = {targetFunc=v; args=tail}
      (ps2, FunCall fc)
    | _ ->
      frt.Panic "Funcall head is not var"
      (ps2, head)


let parseBlock (ps:ParseState) =
  let (ps2, expr) = parseTerm ps |> CnvL psSkipEOL
  let block = GoEval<Block> "Block{[]Stmt{}, expr}"
  (ps2, block)

let vToT (v:Var) =
  v.ftype

// FFunc of FuncType
// FuncType = {targets: []FType}
// LetFuncDef = {name: string; params: []Var; body:Block}
let lfdToFuncType (lfd:LetFuncDef) =
  let rtype = blockToExpr lfd.body |> ExprToType
  let targets = slice.Map vToT lfd.params |> slice.Append rtype
  {FuncType.targets=targets}

// I want to make this func as factory.
// But currently, last arg () is not supported.
// So I return Var here and handle in wrapper.go for a while.
let lfdToFuncVar (lfd:LetFuncDef) =
  let ft = lfdToFuncType lfd |> FFunc
  {Var.name=lfd.name; ftype=ft}

/*
LET_FUNC_DEF = 'let' IDENTIFIER PARAMS (':' TYPE)? '=' EOL? BLOCK
*/
let parseLetFuncDef (ps:ParseState) =
  let ps2 = psConsume LET ps
  let fname = psIdentName ps2
  let (ps3, params) = psNext ps2 |> parseParams
  // TODO: put current func for recursive call.
  let (ps4, block) = psConsume EQ ps3 |> psSkipEOL |> parseBlock
  let lfd =  {LetFuncDef.name=fname; params=params; body=block}
  lfdToFuncVar lfd |> scDefVar ps4.scope fname 
  let stmt = LetFuncDef lfd
  (ps4, stmt)

// FIELD_DEF = ID ':' TYPE
let parseFieldDef (ps:ParseState) =
  let fname = psIdentName ps
  let (ps2, tp) = psNextNOL ps |> psConsume COLON |> parseType
  let ntp = {NameTypePair.name=fname; ftype=tp}
  (ps2, ntp)


let parseFieldDefs (ps:ParseState) : ParseState*[]NameTypePair =
  let (ps2, ntp) = parseFieldDef ps
  if (psCurrentTT ps2) = RBRACE then
    (ps2, [ntp])
  else
    let (ps3, rest) = psConsume SEMICOLON ps2 |> parseFieldDefs
    let result = slice.Prepend ntp rest
    (ps3, result)

let rdToRecType (rd:RecordDef) =
  // golang complaint:
  // S1016 - Use a type conversion instead of manually copying struct fields 
  // {RecordType.name=rd.name; fields=rd.fields}
  GoEval<RecordType> "RecordType(rd)"

// RECORD_DEF = '{' FIELD_DEFS '}'
//
// FIELD_DEFS = FIELD_DEF  (';' FIELD_DEF)*
let parseRecordDef (tname:string) (ps:ParseState) =
  let (ps2, ntps) = psConsume LBRACE ps |> parseFieldDefs |> CnvL (psConsume RBRACE)
  let rd = {RecordDef.name=tname; fields=ntps}
  // register record typedef.
  let recType = rdToRecType rd
  scRegisterRecType ps2.scope recType
  (ps2, rd)


// TYPE_DEF = 'type' ID '=' (RECORD_DEF | UNION_DEF)
//
// RECORD_DEF = '{' FIELD_DEFS '}'
//
// UNION_DEF = '|'...
let parseTypeDef (ps:ParseState) =
  let ps2 = psConsume TYPE ps
  let tname = psIdentName ps2
  let (ps3, rd) = psNextNOL ps2 |> psConsume EQ |> parseRecordDef tname
  let rdstmt = RecordDef rd |> DefStmt
  (ps3, rdstmt)

let parseStmt (ps:ParseState) =
  match psCurrentTT ps with
  | PACKAGE -> parsePackage ps
  | IMPORT -> parseImport ps
  | LET -> parseLetFuncDef ps
  | TYPE -> parseTypeDef ps
  | _ ->
    frt.Panic "Unknown stmt"
    parsePackage ps // never reached this line.

let parseStmts (ps:ParseState) : ParseState*[]Stmt =
  let ps2 = psSkipEOL ps
  if (psCurrentTT ps2) = EOF then
    let s = GoEval<[]Stmt> "[]Stmt{}"
    (ps2, s)
  else
    let (ps3, one) = parseStmt ps |> CnvL psSkipEOL
    let (ps4, rest) = parseStmts ps3
    let ss = slice.Prepend one rest
    (ps4, ss)
