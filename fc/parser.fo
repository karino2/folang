package main

import frt
import slice

let parsePackage (ps:ParseState) =
  psConsume PACKAGE ps
  |> psIdentNameNxL
  |> CnvR RSPackage

let parseImport (ps:ParseState) =
  let ps2 = psConsume IMPORT ps
  if psCurIs IDENTIFIER ps2 then
    // fail to infer in tinyfor. So I do not use pipeline here.
    let (ps3, iname) = psIdentNameNxL ps2
    let rstmt = frt.Sprintf1 "github.com/karino2/folang/pkg/%s" iname |> RSImport
    (ps3, rstmt)
  else
    ps2 
    |> psStringValNxL
    |> CnvR RSImport

let parseFullName (ps:ParseState) : ParseState*string =
   let (ps2, one) = psIdentNameNx ps
   if (psCurrentTT ps2) = DOT then
     let (ps3, rest) = psConsume DOT ps2 |> parseFullName
     (ps3, (one + "." + rest))
   else
     (ps2, one)

/*
  ATOM_TYPE = 'string' | 'int' | '(' ')' | REGISTERED_TYPE | '[' ']' TERM_TYPE | '(' TYPE ')'
*/
let parseAtomType (pType:ParseState->ParseState*FType) (pTerm:ParseState->ParseState*FType) (ps:ParseState) =
  let tk = psCurrent ps
  match tk.ttype with
  | LPAREN ->
    let ps2 = psConsume LPAREN ps
    if (psCurrentTT ps2) = RPAREN then
      let ps3 = psConsume RPAREN ps2
      (ps3, FUnit)
    else
      pType ps2
      |> CnvL (psConsume RPAREN)
  | LSBRACKET ->
    let (ps2, et) = psConsume LSBRACKET ps
                    |> psConsume RSBRACKET
                    |> pTerm
    {SliceType.elemType=et}
    |> FSlice
    |> withPs ps2
  | IDENTIFIER ->
    let tname = tk.stringVal
    let ps3 = psNext ps
    if tname = "string" then
      (ps3, FString)
    elif tname = "int" then
      (ps3, FInt)
    elif tname = "bool" then
      (ps3, FBool)
    else
      let (ps4, fullName) = parseFullName ps
      let (res, ok) = scLookupType ps3.scope fullName
      if ok then
        (ps4, res)
      else
        frt.Panic("type not found.")
        (ps4, FUnit)
  | _ ->
    frt.Panic("Unknown type")
    (ps, FUnit)

/*
TERM_TYPE = ATOM_TYPE | TUPLE_TYPE
TUPLE_TYPE = ATOME_TYPE '*' ATOM_TYPE ('*' ATOME_TYPE)*
*/
let parseTermType (pType:ParseState->ParseState*FType) (ps:ParseState) : ParseState*FType =
  let pAtom = parseAtomType pType (parseTermType pType)
  let (ps2, ft) = pAtom ps
  if (psCurrentTT ps2) = ASTER then
    let (ps3, ft2) = psConsume ASTER ps2
                      |> pAtom
    if (psCurrentTT ps3) = ASTER then
      frt.Panic "More than three elem tuple, NYI"
    {elemTypes=[ft;ft2]}
    |> FTuple
    |> withPs ps3
  else
    (ps2, ft)

/*
  TYPE_ARROWS = TERM_TYPE ('->' TERM_TYPE)*

  return []FType
*/
let parseTypeArrows (pType:ParseState->ParseState*FType) (ps:ParseState) : ParseState*[]FType =
  let (ps2, one) = parseTermType pType ps
  if (psCurrentTT ps2) = RARROW then
    psConsume RARROW ps2
    |> parseTypeArrows pType
    |> CnvR (slice.PushHead one)
  else
    (ps2, [one])

/*
  TYPE =  TERM_TYPE | FUNC_TYPE
*/
let parseType (ps:ParseState) : ParseState*FType =
  let (ps2, tps) = parseTypeArrows parseType ps
  if (slice.Length tps) = 1 then
    slice.Head tps |> withPs ps2
  else
    FFunc {FuncType.targets=tps}
    |> withPs ps2

type Param =
| PVar of Var
| PUnit

/*
	PARAM = '(' ')'
				|	'(' IDENTIFIER : TYPE ')'
*/
let parseParam (ps:ParseState) =
  let ps2 = psConsume LPAREN ps
  let tk = psCurrent ps2
  match tk.ttype with
  | RPAREN ->
     let ps3 = psConsume RPAREN ps2
     (ps3, PUnit)
  | _ ->
    let vname = psIdentName ps2
    let (ps3, tp) = psNext ps2
                    |> psConsume COLON
                    |> parseType
                    |> CnvL (psConsume RPAREN)
    let v = {Var.name=vname; ftype=tp}
    scDefVar ps3.scope vname v
    (ps3, (PVar v))

let parseParams (ps:ParseState) : ParseState*[]Var =
  let (ps2, prm1) = parseParam ps
  match prm1 with
  | PUnit ->
      let zero = GoEval<[]Var> "[]Var{}"
      (ps2, zero)
  | PVar v ->
      let tt = psCurrentTT ps2
      match tt with
      | LPAREN ->
        parseParams ps2
        |> CnvR (slice.PushHead v)
      | _ -> (ps2, [v])

/*
  GO_EVAL = 'GoEval' string | 'GoEval' '<' TYPE '>' string

  It should not have space between 'GoEval' and '<' though currently we just don't care those differences.
*/
let parseGoEval (ps:ParseState) =
  let ps2 = psNext ps
  match psCurrentTT ps2 with
  | LT ->
    let (ps3, ft) = psConsume LT ps2 |> parseType |> CnvL (psConsume GT)
    let (ps4, s) = psStringValNx ps3
    let ge = {goStmt=s; typeArg=ft}
    (ps4, EGoEvalExpr ge)
  | STRING ->
    let (ps3, s) = psStringValNx ps2
    let ge = {goStmt=s; typeArg=FUnit}
    (ps3, EGoEvalExpr ge)
  | _ ->
    frt.Panic "Wrong arg for GoEval"
    (ps2, EUnit)


type fiInfo = {
  recName: string; // "" if not specified.
  nePair: NEPair;
}

/*
  FIELD_INITIALIZER = IDENTIFIER '=' expr | SPECIFIED_INITIALIZER

  Specified initializer specify record name like: {myRec.X = 3; Y=4; Z=5}

  SPECIFIED_INITIALIZER = IDENTIFIER '.' IDENTIFIER '=' expr

  return ps* (string*NEPair) where string contains recname if present ("" if not).
*/
let parseFiIni (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, fname) = psIdentNameNxL ps
  if psCurIs DOT ps2 then
    let (ps3, fname2) = psConsume DOT ps2 |> psIdentNameNxL
    let (ps4, expr) = psConsume EQ ps3 |> psSkipEOL |> parseE
    let fi = {name=fname2;expr=expr}
    (ps4, {recName=fname; nePair=fi})
  else
    let (ps3, expr) = ps2 |> psConsume EQ |> psSkipEOL |> parseE
    let fi = {name=fname;expr=expr}
    (ps3, {recName=""; nePair=fi})

let notEmpty (s:string) =
  s <> ""

type fiListInfo = {
  recName: string; // "" if not specified.
  nePairs: []NEPair;
}

let parseFieldInitializers (parseE: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*fiListInfo =
  let (ps2, fii) = parseFiIni parseE ps
  let nep = fii.nePair
  let recN = fii.recName
  /*
  slice.Map frt.Snd nepTup
  let recs = slice.Map frt.Fst nepTup
               |> slice.Filter notEmpty
  let recN = if slice.IsEmpty recs then "" else slice.Head recs
  */
  if (psCurrentTT ps2) = RBRACE then
    (ps2, {recName=recN; nePairs=[nep]})
  else
    let (ps3, fiInfos) = psConsume SEMICOLON ps2
                      |> parseFieldInitializers parseE
    let recN2 = fiInfos.recName
    let neps = fiInfos.nePairs
    let neps2 = slice.PushHead nep neps
    let recN3 = if recN <> "" then recN else recN2
    (ps3, {recName=recN3; nePairs=neps2})

let NEPToName (nvp:NEPair) =
  nvp.name

let retRecordGen (ok:bool) (rtype: RecordType) (neps: []NEPair) (ps:ParseState) =
  if ok then
    {fieldsNV=neps; recordType=rtype}
    |> ERecordGen |> withPs ps
  else
    frt.Panic "can't find record type."
    (ps, EUnit)


/*
  RECORD_EXPRESISONN = '{' FIELD_INITIALIZERS '}'
  FIELD_INITIALIZERS = FIELD_INITIALIZER (';' FIELD_INITIALIZER)*
  FIELD_INITIALIZER = IDENTIFIER '=' expr | SPECIFIED_INITIALIZER

  Specified initializer specify record name like: {myRec.X = 3; Y=4; Z=5}

  SPECIFIED_INITIALIZER = IDENTIFIER '.' IDENTIFIER '=' expr
*/
let parseRecordGen (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, fiInfos) = psConsume LBRACE ps |> parseFieldInitializers parseE |> CnvL (psConsume RBRACE)
  let neps = fiInfos.nePairs
  let recName = fiInfos.recName
  if recName = "" then
    let (rtype, ok) = slice.Map NEPToName neps |> scLookupRecord ps2.scope
    retRecordGen ok rtype neps ps2
  else
    let (rtype, ok) = scLookupRecordByName ps2.scope recName
    retRecordGen ok rtype neps ps2

let refVar (vname:string) (ps:ParseState) =
  let (vfac, ok) = scLookupVarFac ps.scope vname
  if ok then
    psTypeVarGen ps |> vfac |> EVar
  else
    frt.Panic "Unknown var ref"
    EUnit

/*
  Parsing like field access.
  a.b.c.d

  comeing here on dot for recurse.
  This is workaround because this can't handle like "(fc a b).c".
  We'll parse more seriously later.
*/
let parseFAAfterDot (ps:ParseState) (cur:Expr) : (ParseState*Expr) =
  let (ps2, fname) =  psConsume DOT ps
                      |> psIdentNameNx
  match (ExprToType cur) with
  | FRecord rtype ->
    let fexpr = {targetExpr=cur; targetType=rtype; fieldName=fname}
                 |> EFieldAccess
    if psCurIs DOT ps2 then
      parseFAAfterDot ps2 fexpr
    else
      (ps2, fexpr)
  | _ ->
    frt.Panic "non record type of field access"
    (ps2, EUnit)



/*
  VARIABLE_REF = IDENTIFIER | IDENTIFER '.' IDENTIFIER

  For first case, IDENTIFIER must be in scope.
  For later case, there are 2 types:
    - external pkg access: slice.Take
    - record field access: rec.Person
*/
let parseVarRef (ps:ParseState) =
  let (ps2, firstId) = psIdentNameNx ps
  if (psCurrentTT ps2) <> DOT then
    refVar firstId ps2
    |> withPs ps2
  else
  	// Next is dot. Check whether rec field access or pkg access.
    let (vfac, ok) = scLookupVarFac ps2.scope firstId
    if ok then
  	  // symbol found, record field access.
      psTypeVarGen ps2 |> vfac |> EVar
      |> parseFAAfterDot ps2
    else
      // external pkg access.
      // use original ps for parseFullName
      let (ps3, fullName) = parseFullName ps
      refVar fullName ps3
      |> withPs ps3


let parseAtom (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let cur = psCurrent ps
  let pn = psNext ps
  match cur.ttype with
  | STRING ->
    EStringLiteral cur.stringVal |> withPs pn
  | INT_IMM ->
    EIntImm cur.intVal |> withPs pn
  | TRUE ->
    EBoolLiteral true |> withPs pn
  | FALSE ->
    EBoolLiteral false |> withPs pn
  | LBRACE ->
    parseRecordGen parseE ps
  | LPAREN ->
    if (psCurrentTT pn) = RPAREN then
      (pn, EUnit) |> CnvL (psConsume RPAREN)
    else
      let (ps2, e1) = parseE pn
      if (psCurrentTT ps2) = COMMA then
        let (ps3, e2) = psConsume COMMA ps2
                        |> parseE
        if (psCurrentTT ps3) = COMMA then
          frt.Panic "only pair is supported for tuple expr."
        [e1; e2]
        |> ETupleExpr
        |> withPs (psConsume RPAREN ps3)
      else
        (ps2, e1)
        |> CnvL (psConsume RPAREN)

  | IDENTIFIER ->
    if cur.stringVal = "GoEval" then
      parseGoEval ps
    else
      parseVarRef ps
  | _ ->
    frt.Panic "Unown atom."
    (ps, EUnit)

let psCurIsBinOp (ps:ParseState) =
  let (_, ok) = lookupBinOp (psCurrentTT ps)
  ok

let psNextNonEOLIsBinOp (ps:ParseState) =
  psSkipEOL ps
  |> psCurIsBinOp

let isEndOfTerm (ps:ParseState) =
  match psCurrentTT ps with
  | EOF -> true
  | EOL -> true
  | SEMICOLON -> true
  | RBRACE -> true
  | RPAREN -> true
  | RSBRACKET -> true
  | WITH -> true
  | THEN -> true
  | ELSE -> true
  | COMMA -> true
  | _ -> 
    psNextNonEOLIsBinOp ps

let parseAtomList (parseE: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]Expr =
  let (ps2, one) = parseAtom parseE ps
  if isEndOfTerm ps2 then
    (ps2, [one])
  else
    parseAtomList parseE ps2
    |> CnvR (slice.PushHead one)


/*
  MATCH_RULE = '|' IDENTIFIER IDENTIFIER '->' BLOCK
            |  '|' '_' '->' BLOCK

ex:
	| Record r -> hoge r
  | _-> ""
*/
let parseMatchRule (pBlock: ParseState->ParseState*Block) (target:Expr) (ps:ParseState) =
  let ps2 = psConsume BAR ps
  match psCurrentTT ps2 with
  | UNDER_SCORE -> // default case
    let (ps3, block) = psConsume UNDER_SCORE ps2
                      |> psConsume RARROW
                      |> psSkipEOL
                      |> pBlock
    //  return &MatchRule{&MatchPattern{"_", ""}, block}
    let mp = {caseId="_"; varName=""}
    {pattern=mp; body=block}
    |> withPs ps3
  | _ -> // normal case
    let (ps3, cname) = psIdentNameNx ps2
    let (ps4, vname) = match (psCurrentTT ps3) with
                        | RARROW ->
                          // no content case. use "".
                          (ps3, "")
                        | UNDER_SCORE ->
                          (ps3, "_") |> CnvL psNext
                        | _ ->
                           psIdentNameNx ps3
    let ps5 = psConsume RARROW ps4 |> psSkipEOL |> psPushScope
    if vname <> "" && vname <> "_" then
      let tt = ExprToType target
      // currently, match expect union type
      let fu = GoEval<UnionType> "tt.(FType_FUnion).Value"
      let cp = lookupCase fu cname
      scDefVar ps5.scope vname {Var.name=vname; ftype=cp.ftype}
    let (ps6, block) = pBlock ps5
    let mp = {caseId=cname; varName=vname}
    {pattern=mp; body=block}
    |> withPs ps6

let insideOffside (ps:ParseState) =
  let curCol = psCurCol ps
  let curOff = psCurOffside ps
  curCol >= curOff

let parseMatchRules (pBlock: ParseState->ParseState*Block) (target:Expr) (ps:ParseState) : ParseState*[]MatchRule =
  let (ps2, one) = parseMatchRule pBlock target ps |> CnvL psSkipEOL
  if (psCurrentTT ps2) = BAR && insideOffside ps2 then
    parseMatchRules pBlock target ps2 |> CnvR (slice.PushHead one)
  else
    (ps2, [one])

/*
  MATCH_EXPR = 'match' EXPR 'with' EOL MATCH_RULE+
*/
let parseMatchExpr (pExpr: ParseState->ParseState*Expr) (pBlock: ParseState->ParseState*Block) (ps:ParseState) =
  let (ps2, target) = psConsume MATCH ps |> pExpr |> CnvL (psConsume WITH) |> CnvL psSkipEOL
  let (ps3, rules) = parseMatchRules pBlock target ps2
  {target=target; rules=rules} |> withPs ps3

// expr (; expr)*
let parseSemiExprs (pExpr: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]Expr =
  let (ps2, one) = pExpr ps
  if (psCurrentTT ps2) = SEMICOLON then
    psConsume SEMICOLON ps2
    |> parseSemiExprs pExpr
    |> CnvR (slice.PushHead one)
  else
    (ps2, [one])

/*
  SLICE_EXPR = '[' expr (; expr)* ']'
*/
let parseSliceExpr (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
   psConsume LSBRACKET ps
   |> parseSemiExprs pExpr
   |> CnvL (psConsume RSBRACKET)
   |> CnvR ESlice

/*
  parseIfExpr related
*/


let exprOnlyBlock (expr:Expr) =
   let emp = GoEval<[]Stmt> "[]Stmt{}"
   {Block.stmts=emp; finalExpr=expr}
  

/*
parse single expr and return as block.
This is occur like 'if c then XX else YY' oneliner.
*/
let parseInlineBlock (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
   let (ps2, expr) = pExpr ps
   exprOnlyBlock expr
   |> withPs ps2

/*
IF_EXPR = 'if' expr 'then' block (('elif' expr 'then' block)* 'else' block)?

But for elif, this function parse just after if symbol.
*/
let parseIfAfterIfExpr (pExpr:ParseState->ParseState*Expr) (pBlock:ParseState->ParseState*Block) (ps:ParseState) : ParseState*Expr =
  let (ps2, cond) = pExpr ps |> CnvL (psConsume THEN)
  let tgen = psTypeVarGen ps2
  let recurse = parseIfAfterIfExpr pExpr pBlock
  if psCurIs EOL ps2 then
    let (ps3, tbody) = psSkipEOL ps2
                       |> pBlock
    let ps4 = psSkipEOL ps3
    if psCurIs ELSE ps4 then
      let (pse2, fbody) = psConsume ELSE ps4 |> psSkipEOL |> pBlock
      newIfElseCall tgen cond tbody fbody
      |> withPs pse2
    elif psCurIs ELIF ps4 then
      let (ps5, elseExpr) = psConsume ELIF ps4
                           |> recurse
      let ebody = exprOnlyBlock elseExpr
      newIfElseCall tgen cond tbody ebody
      |> withPs ps5
    else
      // if only. use ps before skip eol
      newIfOnlyCall tgen cond tbody
      |> withPs ps3
  else
		// one line case: if COND then TBODY else FBODY
    let (psi2, tbody) = parseInlineBlock pExpr ps2
    if psCurIs ELSE psi2 then
      let (psi3, fbody) = psConsume ELSE psi2 |> parseInlineBlock pExpr
      newIfElseCall tgen cond tbody fbody
      |> withPs psi3
    else
      newIfOnlyCall tgen cond tbody
      |> withPs psi2


/*
IF_EXPR = 'if' expr 'then' block (('elif' expr 'then' block)* 'else' block)?

- expr must bo bool type.
- both block must be the same return type.
- if there is EOL after 'then', it assumue offside block
- if there is no else block, block return type must be unit.
*/
let parseIfExpr (pExpr:ParseState->ParseState*Expr) (pBlock:ParseState->ParseState*Block) (ps:ParseState) : ParseState*Expr =
  psConsume IF ps
  |> parseIfAfterIfExpr pExpr pBlock

let parseTerm (pExpr: ParseState->ParseState*Expr) (pBlock: ParseState->ParseState*Block) (ps:ParseState) : ParseState*Expr =
  match psCurrentTT ps with
  | MATCH ->
     parseMatchExpr pExpr pBlock ps
     |> CnvR RMatchExpr |> CnvR EReturnableExpr
  | LSBRACKET -> parseSliceExpr pExpr ps
  | IF -> parseIfExpr pExpr pBlock ps 
  | NOT ->
    let (ps2, target) = psConsume NOT ps |> parseTerm pExpr pBlock
    newUnaryNotCall (psTypeVarGen ps2) target
    |> withPs ps2
  | _ ->
    let (ps2, es) = parseAtomList pExpr ps
    if (slice.Length es) = 1 then
      (ps2, (slice.Head es))
    else
      // funcall
      let head = slice.Head es
      let tail = slice.Tail es
      match head with
      | EVar v ->
        let fc = {targetFunc=v; args=tail}
        (ps2, EFunCall fc)
      | _ ->
        frt.Panic "Funcall head is not var"
        (ps2, head)

let lookupBinOpNF (tk:TokenType) =
  let res = lookupBinOp tk
  frt.Fst res

// for recursive call, extract binop later parse.
let parseBinAfter (pEwithMinPrec: int->ParseState->ParseState*Expr) (minPrec: int) (ps:ParseState) (cur:Expr): ParseState*Expr =
  let ps2 = psSkipEOL ps
  if psCurIsBinOp ps2 then
    let btk = psCurrentTT ps2
    let bop = lookupBinOpNF btk
    if bop.precedence < minPrec then
      (ps, cur)
    else
      let (ps3, rhs) = psConsume btk ps2
                       |> pEwithMinPrec (bop.precedence+1)
      let tvgen = psTypeVarGen ps3
      newBinOpCall tvgen btk bop cur rhs
      |> parseBinAfter pEwithMinPrec minPrec ps3
  else
    (ps, cur)

/*
EXPR = TERM (BINOP EXPR)*
*/
let parseExprWithPrec (pBlock: ParseState->ParseState*Block) (minPrec: int) (ps:ParseState) : ParseState*Expr =
  let pExpr = parseExprWithPrec pBlock 1
  let (ps2, expr) = parseTerm pExpr pBlock ps
  let ps3 = psSkipEOL ps2
  if psCurIsBinOp ps3 then
    parseBinAfter (parseExprWithPrec pBlock) minPrec ps3 expr
  else
    (ps2, expr)



let parseExpr (pBlock: ParseState->ParseState*Block) (ps:ParseState) : ParseState*Expr =
  parseExprWithPrec pBlock 1 ps

/*
  parseBlock related.
*/

// STMT = LET_STMT | EXPR
let parseStmt (pExpr: ParseState->ParseState*Expr) (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) =
  match psCurrentTT ps with
  | LET ->
    pLet ps |> CnvR SLetVarDef  
  | _ ->
    pExpr ps |> CnvR SExprStmt


let isEndOfBlock (ps:ParseState) =
  let isOffside = (psCurCol ps) < (psCurOffside ps)
  let isEof = (psCurrentTT ps) = EOF
  isOffside || isEof

let parseStmtList (pExpr: ParseState->ParseState*Expr) (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) : ParseState*[]Stmt =
  let (ps2, one) = parseStmt pExpr pLet ps |> CnvL psSkipEOL
  if isEndOfBlock ps2 then
    (ps2, [one])
  else
    parseStmtList pExpr pLet ps2
    |> CnvR (slice.PushHead one)

/*
  BLOCK = EXPR | (STMT_LIKE EOL)* EXPR
  STMT_LIKE = LET_STMT | EXPR

  In some case, we wanto add local variables in block scope,
  in that case, it's handy to pushScope before calling this function.
*/
let parseBlockAfterPushScope (pExpr: ParseState->ParseState*Expr) (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) =
  let (ps2, sls) = psPushOffside ps |> (parseStmtList pExpr pLet) |> CnvL psPopOffside
  let last = slice.Last sls
  let stmts = slice.PopLast sls
  match last with
  | SExprStmt e ->
    (ps2, {Block.stmts=stmts; finalExpr=e})
  | _ ->
    frt.Panic "block of last is not expr"
    // dummy
    emptyBlock ()
    |> withPs ps2

let parseBlock (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) : ParseState*Block =
  let pExpr = parseExpr (parseBlock pLet)
  psPushScope ps |> parseBlockAfterPushScope pExpr pLet

/*
  LL_ONE_VAR_DEF = 'let' IDENTIFIER '=' expr
*/
let parseLLOneVarDef (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, vname) = psConsume LET ps |> psIdentNameNx |> CnvL (psConsume EQ)
  let (ps3, rhs) = pExpr ps2
  let v = {Var.name=vname; ftype=(ExprToType rhs)}
  scDefVar ps3.scope vname v
  {LetVarDef.lvar=v; rhs=rhs}
  |> LLOneVarDef
  |> withPs ps3


let psIdentOrUSNameNx (ps:ParseState) =
  if psCurIs IDENTIFIER ps then
    psIdentNameNx ps
  else
    let ps2 = psNext ps
    (ps2, "_")

/*
  Destructuring, only support pair for a while like:
  let (a, b) = ...

  LL_DEST_VAR_DEF = 'let' '(' IDENTIFIER ',' IDENTIFIER ')' '=' expr
*/
let parseLLDestVarDef (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, vname1) = psConsume LET ps
                     |> psConsume LPAREN
                     |> psIdentOrUSNameNx
                     |> CnvL (psConsume COMMA)
  let (ps3, vname2) = psIdentOrUSNameNx ps2
                     |> CnvL (psConsume RPAREN)
                     |> CnvL (psConsume EQ)
  let (ps4, rhs) = pExpr ps3
  let rtype = ExprToType rhs
  match rtype with
  | FTuple tup ->
    let v1 = {Var.name=vname1; ftype= slice.Head tup.elemTypes}
    let v2 = {Var.name=vname2; ftype= slice.Last tup.elemTypes}
    if vname1 <> "_" then
      scDefVar ps4.scope vname1 v1
    if vname2 <> "_" then
      scDefVar ps4.scope vname2 v2
    let vs = [v1; v2]
    {LetDestVarDef.lvars=vs; rhs=rhs}
    |> LLDestVarDef
    |> withPs ps4
  | _ ->
    frt.Panic "Destructuring let, but rhs is not tuple. NYI."
    let dummy = GoEval<[]Var> "[]Var{}"
    (ps2, LLDestVarDef {LetDestVarDef.lvars=dummy; rhs=EUnit})



let vToT (v:Var) =
  v.ftype

// I want to make this func as factory.
// But currently, last arg () is not supported.
// So I return Var here and handle in wrapper.go for a while.
let lfdToFuncVar (lfd:LetFuncDef) =
  lfd.fvar

/*
  LET_FUNC_DEF = 'let' IDENTIFIER PARAMS (':' TYPE)? '=' EOL? BLOCK
*/
let parseLetFuncDef (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) =
  let ps2 = psConsume LET ps
  let fname = psIdentName ps2
  let (ps3, params) = psNext ps2 |> parseParams
  // TODO: put current func for recursive call.
  let (ps4, block) = psConsume EQ ps3 |> psSkipEOL |> parseBlock pLet
  // build lfd func var here for a while.
  let rtype = blockToExpr block |> ExprToType
  let targets = if (slice.Length params) = 0 then
                  [FUnit; rtype]
                else
                  slice.Map vToT params
                  |> slice.PushLast rtype
  let ft = {FuncType.targets=targets} |> FFunc
  let fnvar = {Var.name=fname; ftype=ft}
  {fvar=fnvar; params=params; body=block}
  |> withPs ps4

let tvToN (tv:TypeVar) =
  tv.name

let parseRootLetFuncDef (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) =
  let (ps2, lfd) = parseLetFuncDef pLet ps
  // resolve lfd here.
  lfdToFuncVar lfd |> scDefVar ps.scope lfd.fvar.name 
  let tnames = tvaListAlloced ps.tva |> slice.Map tvToN
  let rfd = Infer tnames lfd
  (ps2, rfd)

/*
LET_VAR_DEF = LL_ONE_VAR_DEF | LL_DEST_VAR_DEF
*/
let parseLetVarDef (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  let peekPs = psConsume LET ps
  if psCurIs LPAREN peekPs then
    parseLLDestVarDef pExpr ps
  else
    parseLLOneVarDef pExpr ps

/*
  LET = LET_DEST_VAR_DEF | LET_VAR_DEF | LET_FUNC_DEF

  LET_VAR_DEF = 'let' IDENTIFIER '=' expr
  LET_DEST_VAR_DEF = 'let' '(' IDENTIFIER, IDENTIFIER ')' '=' expr
*/
let parseRootLet (pExpr:ParseState->ParseState*Expr) (ps0:ParseState) =
  let ps = psResetTmpCtx ps0
  let pLet = parseLetVarDef pExpr
  let psN = psNext ps
  match psCurrentTT psN with
  | LPAREN ->
    parseRootLetFuncDef pLet ps
    |> CnvR RSRootFuncDef
  | _ ->
    let psNN = psNext psN
    match psCurrentTT psNN with
    | EQ ->
      frt.Panic "Root let var def, NYI"
      (ps, (RSImport "dummy"))
    | _ ->
      parseRootLetFuncDef pLet ps
      |> CnvR RSRootFuncDef
     
/*
  parse RecordDef related.
*/

// FIELD_DEF = ID ':' TYPE
let parseFieldDef (ps:ParseState) =
  let fname = psIdentName ps
  let (ps2, tp) = psNextNOL ps |> psConsume COLON |> parseType
  let ntp = {NameTypePair.name=fname; ftype=tp}
  (ps2, ntp)


let parseFieldDefs (ps:ParseState) : ParseState*[]NameTypePair =
  let (ps2, ntp) = psSkipEOL ps |> parseFieldDef
  if (psCurrentTT ps2) = RBRACE then
    (ps2, [ntp])
  else
    let ps3 = psConsume SEMICOLON ps2 |> psSkipEOL
    if psCurIs RBRACE ps3 then
      (ps3, [ntp])
    else
      parseFieldDefs ps3
      |> CnvR (slice.PushHead ntp)

let rdToRecType (rd:RecordDef) =
  // golang complaint:
  // S1016 - Use a type conversion instead of manually copying struct fields 
  // {RecordType.name=rd.name; fields=rd.fields}
  GoEval<RecordType> "RecordType(rd)"

/*
  RECORD_DEF = '{' FIELD_DEFS '}'
  FIELD_DEFS = FIELD_DEF  (';' FIELD_DEF)*
*/
let parseRecordDef (tname:string) (ps:ParseState) =
  let (ps2, ntps) = psConsume LBRACE ps |> parseFieldDefs |> CnvL (psConsume RBRACE)
  let rd = {RecordDef.name=tname; fields=ntps}
  // register record typedef.
  rdToRecType rd |> scRegisterRecType ps2.scope
  (ps2, rd)

/*
  parse UnionDef related.
*/

// CASE_DEF = '|' IDENIFIER OF TYPE
let parseOneCaseDef (ps:ParseState) =
  let (ps2, cname) = psConsume BAR ps |> psIdentNameNx
  match psCurrentTT ps2 with
  | OF ->
    let (ps3, tp) = psConsume OF ps2 |> parseType
    let cs = {NameTypePair.name=cname; ftype=tp}
    (ps3, cs)
  | _ ->
    // no "of", unit case.
    let ps3 = psConsume EOL ps2
    let cs = {NameTypePair.name=cname; ftype=FUnit}
    (ps3, cs)

let parseCaseDefs (ps:ParseState) : ParseState*[]NameTypePair =
  let (ps2, cs) = parseOneCaseDef ps
  let ps3 = psSkipEOL ps2
  if (psCurrentTT ps3) = BAR then
    parseCaseDefs ps3 |> CnvR (slice.PushHead cs)
  else
    (ps2, [cs])

/*
  UNION_DEF = CASE_DEF (EOL CASE_DEF)* EOL
  CASE_DEF = '|' IDENIFIER OF TYPE
*/
let parseUnionDef (tname:string) (ps:ParseState) =
  let (ps2, css) = parseCaseDefs ps
  let ud = {UnionDef.name=tname; cases=css}
  udRegisterToScope ps2.scope ud
  (ps2, ud)
  

// TYPE_DEF = 'type' ID '=' (RECORD_DEF | UNION_DEF)
//
// RECORD_DEF = '{' FIELD_DEFS '}'
//
// UNION_DEF = '|'...
let parseTypeDef (ps:ParseState) =
  let (ps2, tname) = psConsume TYPE ps |> psIdentNameNxL |> CnvL (psConsume EQ) |> CnvL psSkipEOL
  match psCurrentTT ps2 with
  | LBRACE ->
    parseRecordDef tname ps2 |> CnvR DRecordDef |> CnvR RSDefStmt
  | BAR ->
    parseUnionDef tname ps2  |> CnvR DUnionDef |> CnvR RSDefStmt
  | _ ->
    frt.Panic "NYI"
    (ps2, (RSImport "dummy"))

/*
  PackageInfo related:
*/

/*
  EXT_TYPE_DEF = 'type' IDENTIFIER
*/
let parseExtTypeDef (pi:PackageInfo) (ps:ParseState) =
  let (ps2, tname) = psConsume TYPE ps |> psIdentNameNx
  let etype = piRegEType pi tname
  scRegisterType ps2.scope tname etype
  ps2

/*
  TYPE_PARAMS = '<' IDENTIFIER (',' IDENTIFIER)* '>'

  call this function after consume '<'
*/
let parseTypeParams (ps:ParseState) : ParseState*[]string =
  let (ps2, tname) = psIdentNameNx ps
  if (psCurrentTT ps2) = COMMA then
    psConsume COMMA ps2
    |> parseTypeParams
    |> CnvR (slice.PushHead tname)
  else
    (ps2, [tname])

let regTypeVar (ps:ParseState) (tname:string) =
  FTypeVar {TypeVar.name=tname}
  |> scRegisterType ps.scope tname

let psRegTypeVars (ps:ParseState) (tnames:[]string) =
  slice.Iter (regTypeVar ps) tnames

/*
  EXT_FUNC_DEF = 'let' IDENTIFIER (TYPE_PARAM)? ':' FUNC_TYPE
*/
let parseExtFuncDef (pi:PackageInfo) (ps:ParseState) =
  let (ps2, fname) = psConsume LET ps |> psIdentNameNx
  let (ps3, tnames) = if (psCurrentTT ps2) = LT then
                        psConsume LT ps2
                        |> parseTypeParams
                        |> CnvL (psConsume GT)
                      else
                        GoEval<[]string> "[]string{}"
                        |>withPs ps2            
  psRegTypeVars ps3 tnames
  let (ps4, fts) = psConsume COLON ps3
                   |> parseTypeArrows parseType
  let ff = {tparams=tnames; targets=fts}
  piRegFF pi fname ff ps4
  ps4

let parseExtDef (pi:PackageInfo) (ps:ParseState) =
  match (psCurrentTT ps) with
  | LET -> parseExtFuncDef pi ps
  | TYPE -> parseExtTypeDef pi ps
  | _ ->
    frt.Panic "Unknown pkginfo def"
    ps

let parseExtDefs (pi:PackageInfo) (ps:ParseState) : ParseState =
   let ps2 = parseExtDef pi ps |> psSkipEOL
   if isEndOfBlock ps2 then
     ps2
   else
     parseExtDefs pi ps2

/*
  PACKAGE_INFO = 'package_info' IDENTIFIER '=' EOL (OFFSIDE EXT_DEF EOL)*
  EXT_DEF = (EXT_TYPE_DEF|EXT_FUNC_DEF)
*/
let parsePackageInfo (ps:ParseState) =
  let ps2 = psConsume PACKAGE_INFO ps
  let (ps3, pkgName) = if (psCurrentTT ps2) = UNDER_SCORE then
                         (ps2, "_")
                         |> CnvL psNext
                       else
                         psIdentNameNx ps2
  let ps4 = psConsume EQ ps3
            |> psSkipEOL
            |> psPushOffside
            |> psPushScope
  let pi = NewPackageInfo pkgName
  let ps5 = parseExtDefs pi ps4
            |> psPopScope
            |> psPopOffside
  piRegAll pi ps5.scope
  (ps5, (RSPackageInfo pi))

/*
  parse Stmt related.
*/

let parseRootOneStmt (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  match psCurrentTT ps with
  | PACKAGE -> parsePackage ps
  | IMPORT -> parseImport ps
  | LET -> parseRootLet pExpr ps
  | TYPE -> parseTypeDef ps
  | PACKAGE_INFO -> parsePackageInfo ps
  | _ ->
    frt.Panic "Unknown stmt"
    parsePackage ps // never reached this line.

let parseRootStmts (pExpr: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]RootStmt =
  let ps2 = psSkipEOL ps
  if (psCurrentTT ps2) = EOF then
    let s = GoEval<[]RootStmt> "[]RootStmt{}"
    (ps2, s)
  else
    let (ps3, one) = parseRootOneStmt pExpr ps2 |> CnvL psSkipEOL
    let (ps4, rest) = parseRootStmts pExpr ps3
    let ss = slice.PushHead one rest
    (ps4, ss)
