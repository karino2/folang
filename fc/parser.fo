package main

import frt
import slice

// wrapper types.
/*
package_info _ =
  type Scope
  let NewScope: ()->Scope
*/

type ParseState = {
  tkz: Tokenizer;
  // offsideCol: []int;
  // scope: Scope;
  // typeDefCtx
}

let initParse (src: string) =
  let tkz = newTkz src
  {tkz=tkz}

let psCurrent (ps:ParseState) =
  ps.tkz.current

let psCurrentTT (ps:ParseState) =
  let tk = psCurrent ps
  tk.ttype

let psNext (ps:ParseState) =
   let ntk = tkzNext ps.tkz
   {tkz=ntk}

let psNextNOL (ps:ParseState) =
   let ntk = tkzNextNOL ps.tkz
   {tkz=ntk}

let psSkipEOL (ps:ParseState) =
   if (psCurrentTT ps) = EOL then
     psNextNOL ps
    else
     ps


let psExpect (ttype:TokenType) (ps:ParseState) =
  let cur = psCurrent ps
  if cur.ttype <> ttype then
    frt.Panic("non expected token")
  ()

let psConsume (ttype:TokenType) (ps:ParseState) =
  psExpect ttype ps
  psNext ps


let psIdentName (ps:ParseState) =
  psExpect IDENTIFIER ps
  let cur = psCurrent ps
  cur.stringVal

let parsePackage (ps:ParseState) =
  let ps2 = psConsume PACKAGE ps
  let pname = psIdentName ps2
  let ps3 = psNextNOL ps2
  let pkg = Package pname
  (ps3, pkg)


/*
TYPE = ATOM_TYPE

ATOM_TYPE = 'string' | 'int' | '(' ')'

TODO:
ATOM_TYPE = 'string' | 'int' | '(' ')' | REGISTERED_TYPE | '[' ']' TYPE
*/
let parseType (ps:ParseState) =
  let tk = psCurrent ps
  match tk.ttype with
  | LPAREN ->
    let ps2 = ps |> psConsume LPAREN |> psConsume RPAREN
    (ps2, FUnit)
  | IDENTIFIER ->
    let tname = tk.stringVal
    let ps3 = psNext ps
    let rtype = if tname = "string" then
                  FString
                elif tname = "int" then
                  FInt
                elif tname = "bool" then
                  FBool
                else
                  frt.Panic("NYI")
                  FUnit
    (ps3, rtype)
  | _ ->
    frt.Panic("Unknown type")
    (ps, FUnit)


type Param =
| PVar of Var
| PUnit

/*
	PARAM = '(' ')'
				|	'(' IDENTIFIER : TYPE ')'

*/
let parseParam (ps:ParseState) =
  let ps2 = psConsume LPAREN ps
  let tk = psCurrent ps2
  match tk.ttype with
  | RPAREN ->
     let ps3 = psConsume RPAREN ps2
     (ps3, PUnit)
  | _ ->
    let vname = psIdentName ps2
    let ps3 = psNext ps2 |> psConsume COLON
    let (ps4, tp) = parseType ps3
    let ps5 = psConsume RPAREN ps4
    let v = {Var.name=vname; ftype=tp}
    // TODO: define var to scope here.
    (ps5, (PVar v))

let parseParams (ps:ParseState) : ParseState*[]Var =
  let (ps2, prm1) = parseParam ps
  match prm1 with
  | PUnit ->
      let zero = GoEval<[]Var> "[]Var{}"
      (ps2, zero)
  | PVar v ->
      let tt = psCurrentTT ps2
      match tt with
      | LPAREN ->
        let ftp2 = parseParams ps2
        let ps3 = frt.Fst ftp2
        let prms2 = frt.Snd ftp2
        let pas3 = slice.Append v prms2
        (ps3, pas3)
      | _ -> (ps2, [v])

let parseAtom (ps:ParseState) =
  let cur = psCurrent ps
  let expr = match cur.ttype with
              | STRING -> StringLiteral cur.stringVal
              | INT_IMM -> IntImm cur.intVal
              | _ -> Unit
  let ps2 = psNext ps
  (ps2, expr)

let parseBlock (ps:ParseState) =
  let (ps2, expr) = parseAtom ps
  let block = GoEval<Block> "Block{[]Stmt{}, expr}"
  let ps3 = psSkipEOL ps2
  (ps3, block)

/*
LET_FUNC_DEF = 'let' IDENTIFIER PARAMS (':' TYPE)? '=' EOL? BLOCK
*/
let parseLetFuncDef (ps:ParseState) =
  let ps2 = psConsume LET ps
  let fname = psIdentName ps2
  let (ps3, params) = psNext ps2 |> parseParams
  // TODO: put current func for recursive call.
  let (ps4, block) = psConsume EQ ps3 |> psSkipEOL |> parseBlock
  let stmt = LetFuncDef {LetFuncDef.name=fname; params=params; body=block}
  (ps4, stmt)
  
  

