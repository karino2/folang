package main

import frt
import slice

let parsePackage (ps:ParseState) =
  psConsume PACKAGE ps
  |> psIdentNameNxL
  |> CnvR RSPackage

let parseImport (ps:ParseState) =
  let ps2 = psConsume IMPORT ps
  if psCurIs IDENTIFIER ps2 then
    // fail to infer in tinyfor. So I do not use pipeline here.
    let (ps3, iname) = psIdentNameNxL ps2
    let rstmt = frt.Sprintf1 "github.com/karino2/folang/pkg/%s" iname |> RSImport
    (ps3, rstmt)
  else
    ps2 
    |> psStringValNxL
    |> CnvR RSImport

let parseFullName (ps:ParseState) : ParseState*string =
   let (ps2, one) = psIdentNameNx ps
   if (psCurrentTT ps2) = DOT then
     let (ps3, rest) = psConsume DOT ps2 |> parseFullName
     (ps3, (one + "." + rest))
   else
     (ps2, one)

/*
  TYPE_LIST = TYPE (',' TYPE)*
*/
let parseTypeList (pType: ParseState->ParseState*FType) (ps:ParseState) : ParseState*[]FType =
  let (ps2, one) = pType ps
  if psCurIs COMMA ps2 then
    psConsume COMMA ps2
    |> parseTypeList pType
    |> CnvR (slice.PushHead one)
  else
    (ps2, [one])

/*
  if cur is '<', parse '<' TYPE_LIST '>',
  else return empty type list with current ps.
*/
let mightParseSpecifiedTypeList (pType:ParseState->ParseState*FType) (ps:ParseState) =
  if psCurIs LT ps then
    psConsume LT ps
    |> (parseTypeList pType)
    |> CnvL (psConsume GT)
  else
    emptyFtps ()
    |> withPs ps


/*
  ATOM_TYPE = 'string' | 'int' | '(' ')' | REGISTERED_TYPE | '(' TYPE ')'
*/
let parseAtomType (pType:ParseState->ParseState*FType) (ps:ParseState) =
  let tk = psCurrent ps
  match tk.ttype with
  | LPAREN ->
    let ps2 = psConsume LPAREN ps
    if (psCurrentTT ps2) = RPAREN then
      let ps3 = psConsume RPAREN ps2
      (ps3, FUnit)
    else
      pType ps2
      |> CnvL (psConsume RPAREN)
  | IDENTIFIER ->
    let tname = tk.stringVal
    let ps3 = psNext ps
    if tname = "string" then
      (ps3, FString)
    elif tname = "int" then
      (ps3, FInt)
    elif tname = "bool" then
      (ps3, FBool)
    elif tname = "any" then
      (ps3, FAny)
    else
      let (ps4, fullName) = parseFullName ps
      let (rfac, ok) = scLookupTypeFac ps3.scope fullName
      if ok then
        mightParseSpecifiedTypeList pType ps4
        |> CnvR rfac
      elif psInsideTypeDef ps4 then
        // unknown type inside type def.
        // This might be defined in later 'and'
        // So return typevar of TypeVarCtx and replace later
        let tvarf = tdctxTVFAlloc ps4.tdctx fullName
        (ps4, tvarf)
      else
        frt.Panicf1 "type not found: %s." fullName
        (ps4, FUnit)
  | _ ->
    frt.Panic("Unknown type")
    (ps, FUnit)



/*
  TERM_TYPE = ATOM_TYPE | TUPLE_TYPE
  TUPLE_TYPE = ATOM_TYPE '*' ELEM_TYPE ('*' ELEM_TYPE)*

  []T*U should parse [](T*U).
  So tuple is higher precedance.

  But T*[]U is also valid. So right hand side must be ELEM_TYPE.
*/
let parseTermType (pType:ParseState->ParseState*FType) (pElem:ParseState->ParseState*FType) (ps:ParseState) : ParseState*FType =
  let pAtom = parseAtomType pType
  let (ps2, ft) = pAtom ps
  if (psCurrentTT ps2) = ASTER then
    let (ps3, ft2) = psConsume ASTER ps2
                      |> pElem
    if (psCurrentTT ps3) = ASTER then
      frt.Panic "More than three elem tuple, NYI"
    {ElemTypes=[ft;ft2]}
    |> FTuple
    |> withPs ps3
  else
    (ps2, ft)


/*
ELEM_TYPE = TERM_TYPE | '[' ']' ELEM_TYPE

[]T*U should parse [](T*U)
*/
let parseElemType (pType: ParseState->ParseState*FType) (ps:ParseState) : ParseState*FType =
  let recurse = parseElemType pType
  if psCurIs LSBRACKET ps then
    let (ps2, et) = psConsume LSBRACKET ps
                    |> psConsume RSBRACKET
                    |> recurse
    {SliceType.ElemType=et}
    |> FSlice
    |> withPs ps2
  else
    parseTermType pType recurse ps

/*
  TYPE_ARROWS = ELEM_TYPE ('->' ELEM_TYPE)*

  return []FType
*/
let parseTypeArrows (pType:ParseState->ParseState*FType) (ps:ParseState) : ParseState*[]FType =
  let (ps2, one) = parseElemType pType ps
  if (psCurrentTT ps2) = RARROW then
    psConsume RARROW ps2
    |> parseTypeArrows pType
    |> CnvR (slice.PushHead one)
  else
    (ps2, [one])

/*
  TYPE =  TERM_TYPE | FUNC_TYPE
*/
let parseType (ps:ParseState) : ParseState*FType =
  let (ps2, tps) = parseTypeArrows parseType ps
  if (slice.Length tps) = 1 then
    slice.Head tps |> withPs ps2
  else
    FFunc {FuncType.Targets=tps}
    |> withPs ps2

type Param =
| PVar of Var
| PUnit

let psNewTypeVar (ps:ParseState) =
  let tgen = psTypeVarGen ps
  tgen ()

/*
	PARAM = '(' ')'
				|	'(' IDENTIFIER : TYPE ')'
        | IDENTIFIER
*/
let parseParam (ps:ParseState) =
  match psCurrentTT ps with
  | LPAREN ->
    let ps2 = psConsume LPAREN ps
    let tk = psCurrent ps2
    match tk.ttype with
    | RPAREN ->
      let ps3 = psConsume RPAREN ps2
      (ps3, PUnit)
    | _ ->
      let vname = psIdentName ps2
      let (ps3, tp) = psNext ps2
                      |> psConsume COLON
                      |> parseType
                      |> CnvL (psConsume RPAREN)
      let v = {Var.Name=vname; Ftype=tp}
      scDefVar ps3.scope vname v
      (ps3, (PVar v))
  | IDENTIFIER ->
    let (ps2, vname) = psIdentNameNx ps
    let ftv = psNewTypeVar ps2 |> FTypeVar
    let v = {Var.Name=vname; Ftype=ftv}
    scDefVar ps2.scope vname v
    (ps2, (PVar v))

let parseParams (ps:ParseState) : ParseState*[]Var =
  let (ps2, prm1) = parseParam ps
  match prm1 with
  | PUnit ->
      let zero = GoEval<[]Var> "[]Var{}"
      (ps2, zero)
  | PVar v ->
      let tt = psCurrentTT ps2
      match tt with
      | LPAREN ->
        parseParams ps2
        |> CnvR (slice.PushHead v)
      | IDENTIFIER ->
        parseParams ps2
        |> CnvR (slice.PushHead v)
      | _ -> (ps2, [v])

/*
  GO_EVAL = 'GoEval' string | 'GoEval' '<' TYPE '>' string

  It should not have space between 'GoEval' and '<' though currently we just don't care those differences.
*/
let parseGoEval (ps:ParseState) =
  let ps2 = psNext ps
  match psCurrentTT ps2 with
  | LT ->
    let (ps3, ft) = psConsume LT ps2 |> parseType |> CnvL (psConsume GT)
    let (ps4, s) = psStringValNx ps3
    let ge = {GoStmt=s; TypeArg=ft}
    (ps4, EGoEvalExpr ge)
  | STRING ->
    let (ps3, s) = psStringValNx ps2
    let ge = {GoStmt=s; TypeArg=FUnit}
    (ps3, EGoEvalExpr ge)
  | _ ->
    frt.Panic "Wrong arg for GoEval"
    (ps2, EUnit)


type fiInfo = {
  RecName: string; // "" if not specified.
  NePair: NEPair;
}

/*
  FIELD_INITIALIZER = IDENTIFIER '=' expr | SPECIFIED_INITIALIZER

  Specified initializer specify record name like: {myRec.X = 3; Y=4; Z=5}

  SPECIFIED_INITIALIZER = IDENTIFIER '.' IDENTIFIER '=' expr

  return ps* (string*NEPair) where string contains recname if present ("" if not).
*/
let parseFiIni (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, fname) = psIdentNameNxL ps
  if psCurIs DOT ps2 then
    let (ps3, fname2) = psConsume DOT ps2 |> psIdentNameNxL
    let (ps4, expr) = psConsume EQ ps3 |> psSkipEOL |> parseE
    let fi = {Name=fname2;Expr=expr}
    (ps4, {RecName=fname; NePair=fi})
  else
    let (ps3, expr) = ps2 |> psConsume EQ |> psSkipEOL |> parseE
    let fi = {Name=fname;Expr=expr}
    (ps3, {RecName=""; NePair=fi})

type fiListInfo = {
  RecName: string; // "" if not specified.
  NePairs: []NEPair;
}

let parseFieldInitializers (parseE: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*fiListInfo =
  let (ps2, fii) = parseFiIni parseE ps
  let nep = fii.NePair
  let recN = fii.RecName
  if (psCurrentTT ps2) = RBRACE then
    (ps2, {RecName=recN; NePairs=[nep]})
  else
    let (ps3, fiInfos) = psConsume SEMICOLON ps2
                      |> parseFieldInitializers parseE
    let recN2 = fiInfos.RecName
    let neps = fiInfos.NePairs
    let neps2 = slice.PushHead nep neps
    let recN3 = if recN <> "" then recN else recN2
    (ps3, {RecName=recN3; NePairs=neps2})

let NEPToName (nvp:NEPair) =
  nvp.Name

let retRecordGen (ok:bool) (rtype: RecordType) (neps: []NEPair) (ps:ParseState) =
  if ok then
    {FieldsNV=neps; RecordType=rtype}
    |> ERecordGen |> withPs ps
  else
    frt.Panic "can't find record type."
    (ps, EUnit)


/*
  RECORD_EXPRESISONN = '{' FIELD_INITIALIZERS '}'
  FIELD_INITIALIZERS = FIELD_INITIALIZER (';' FIELD_INITIALIZER)*
  FIELD_INITIALIZER = IDENTIFIER '=' expr | SPECIFIED_INITIALIZER

  Specified initializer specify record name like: {myRec.X = 3; Y=4; Z=5}

  SPECIFIED_INITIALIZER = IDENTIFIER '.' IDENTIFIER '=' expr
*/
let parseRecordGen (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, fiInfos) = psConsume LBRACE ps |> parseFieldInitializers parseE |> CnvL (psConsume RBRACE)
  let neps = fiInfos.NePairs
  let recName = fiInfos.RecName
  if recName = "" then
    let (rtype, ok) = slice.Map NEPToName neps |> scLookupRecord ps2.scope
    retRecordGen ok rtype neps ps2
  else
    let (rtype, ok) = scLookupRecordByName ps2.scope recName
    retRecordGen ok rtype neps ps2

let refVar (vname:string) (stlist:[]FType) (ps:ParseState) =
  let (vfac, ok) = scLookupVarFac ps.scope vname
  if ok then
    psTypeVarGen ps |> vfac stlist |> EVarRef
  else
    frt.Sprintf1 "Unknown var ref: %s" vname
    |> frt.Panic
    EUnit

/*
  Parsing like field access.
  a.b.c.d

  comeing here on dot for recurse.
  This is workaround because this can't handle like "(fc a b).c".
  We'll parse more seriously later.
*/
let parseFAAfterDot (ps:ParseState) (cur:Expr) : (ParseState*Expr) =
  let (ps2, fname) =  psConsume DOT ps
                      |> psIdentNameNx
  let fexpr = {TargetExpr=cur; FieldName=fname}
              |> EFieldAccess
  if psCurIs DOT ps2 then
    parseFAAfterDot ps2 fexpr
  else
    (ps2, fexpr)




/*
  VARIABLE_REF = VARIABLE_REF_BASE ('<' TYPE_LIST '>')
  VARIABLE_REF_BASE = IDENTIFIER | IDENTIFER '.' IDENTIFIER

  For first case, IDENTIFIER must be in scope.
  For later case, there are 2 types:
    - external pkg access: slice.Take
    - record field access: rec.Person

  between VARIABLE_REF_BASE and '<', there must not be space to distinguish "a < b > 3" and "a<b>".
  This is special.
*/
let parseVarRef (ps:ParseState) =
  let firstId = psIdentName ps
  let (ps2, stlist) = if psIsNeighborLT ps then
                        psNext ps
                        |> mightParseSpecifiedTypeList parseType
                      else
                        emptyFtps ()
                        |> withPs (psNext ps)
  if (psCurrentTT ps2) <> DOT then
    refVar firstId stlist ps2
    |> withPs ps2
  else
  	// Next is dot. Check whether rec field access or pkg access.
    let (vfac, ok) = scLookupVarFac ps2.scope firstId
    if ok then
  	  // symbol found, record field access.
      psTypeVarGen ps2 |> vfac (emptyFtps ()) |> EVarRef
      |> parseFAAfterDot ps2
    else
      // external pkg access.
      // use original ps for parseFullName
      let (ps3, fullName) = parseFullName ps
      let (ps4, stlist) = mightParseSpecifiedTypeList parseType ps3
      refVar fullName stlist ps4
      |> withPs ps4

let isSemiExprEnd ps =
  (psCurrentTT ps) <> SEMICOLON 

// expr (; expr)*
let parseSemiExprs (pExpr: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]Expr =  
  ParseList2 pExpr isSemiExprEnd (psConsume SEMICOLON) ps

/*
  SLICE_EXPR = '[' expr (; expr)* ']'
*/
let parseSliceExpr (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
   psConsume LSBRACKET ps
   |> parseSemiExprs pExpr
   |> CnvL (psConsume RSBRACKET)
   |> CnvR ESlice

/*
  ATOM = LITERAL | (EXPR) | RECORD_GEN | SLICE_EXPR | VAR_REF
*/
let parseAtom (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let cur = psCurrent ps
  let pn = psNext ps
  match cur.ttype with
  | STRING ->
    EStringLiteral cur.stringVal |> withPs pn
  | INT_IMM ->
    EIntImm cur.intVal |> withPs pn
  | TRUE ->
    EBoolLiteral true |> withPs pn
  | FALSE ->
    EBoolLiteral false |> withPs pn
  | LBRACE ->
    parseRecordGen parseE ps
  | LSBRACKET ->
    parseSliceExpr parseE ps
  | LPAREN ->
    if (psCurrentTT pn) = RPAREN then
      (pn, EUnit) |> CnvL (psConsume RPAREN)
    else
      let (ps2, e1) = parseE pn
      if (psCurrentTT ps2) = COMMA then
        let (ps3, e2) = psConsume COMMA ps2
                        |> parseE
        if (psCurrentTT ps3) = COMMA then
          frt.Panic "only pair is supported for tuple expr."
        [e1; e2]
        |> ETupleExpr
        |> withPs (psConsume RPAREN ps3)
      else
        (ps2, e1)
        |> CnvL (psConsume RPAREN)
  | IDENTIFIER ->
    if cur.stringVal = "GoEval" then
      parseGoEval ps
    else
      parseVarRef ps
  | _ ->
    frt.Panic "Unown atom."
    (ps, EUnit)

let psCurIsBinOp (ps:ParseState) =
  let (_, ok) = lookupBinOp (psCurrentTT ps)
  ok

let psNextNonEOLIsBinOp (ps:ParseState) =
  psSkipEOL ps
  |> psCurIsBinOp

let isEndOfTerm (ps:ParseState) =
  match psCurrentTT ps with
  | EOF -> true
  | EOL -> true
  | SEMICOLON -> true
  | RBRACE -> true
  | RPAREN -> true
  | RSBRACKET -> true
  | WITH -> true
  | THEN -> true
  | ELSE -> true
  | COMMA -> true
  | _ -> 
    psNextNonEOLIsBinOp ps

let parseAtomList (parseE: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]Expr =
  let (ps2, one) = parseAtom parseE ps
  if isEndOfTerm ps2 then
    (ps2, [one])
  else
    parseAtomList parseE ps2
    |> CnvR (slice.PushHead one)


/*
  MATCH_RULE = '|' IDENTIFIER IDENTIFIER '->' BLOCK
            |  '|' '_' '->' BLOCK

ex:
	| Record r -> hoge r
  | _-> ""
*/
let parseMatchRule (pBlock: ParseState->ParseState*Block) (target:Expr) (ps:ParseState) =
  let ps2 = psConsume BAR ps
  match psCurrentTT ps2 with
  | UNDER_SCORE -> // default case
    let (ps3, block) = psConsume UNDER_SCORE ps2
                      |> psConsume RARROW
                      |> psSkipEOL
                      |> pBlock
    //  return &MatchRule{&MatchPattern{"_", ""}, block}
    let mp = {CaseId="_"; VarName=""}
    {Pattern=mp; Body=block}
    |> withPs ps3
  | _ -> // normal case
    let (ps3, cname) = psIdentNameNx ps2
    let (ps4, vname) = match (psCurrentTT ps3) with
                        | RARROW ->
                          // no content case. use "".
                          (ps3, "")
                        | UNDER_SCORE ->
                          (ps3, "_") |> CnvL psNext
                        | _ ->
                           psIdentNameNx ps3
    let ps5 = psConsume RARROW ps4 |> psSkipEOL |> psPushScope
    if vname <> "" && vname <> "_" then
      let tt = ExprToType target
      // currently, match expect union type
      let fu = GoEval<UnionType> "tt.(FType_FUnion).Value"
      let cp = lookupCase fu cname
      scDefVar ps5.scope vname {Var.Name=vname; Ftype=cp.Ftype}
    let (ps6, block) = pBlock ps5
    let mp = {CaseId=cname; VarName=vname}
    {Pattern=mp; Body=block}
    |> withPs ps6

let insideOffside (ps:ParseState) =
  let curCol = psCurCol ps
  let curOff = psCurOffside ps
  curCol >= curOff

let parseMatchRules (pBlock: ParseState->ParseState*Block) (target:Expr) (ps:ParseState) : ParseState*[]MatchRule =
  let (ps2, one) = parseMatchRule pBlock target ps |> CnvL psSkipEOL
  if (psCurrentTT ps2) = BAR && insideOffside ps2 then
    parseMatchRules pBlock target ps2 |> CnvR (slice.PushHead one)
  else
    (ps2, [one])

/*
  MATCH_EXPR = 'match' EXPR 'with' EOL MATCH_RULE+
*/
let parseMatchExpr (pExpr: ParseState->ParseState*Expr) (pBlock: ParseState->ParseState*Block) (ps:ParseState) =
  let (ps2, target) = psConsume MATCH ps |> pExpr |> CnvL (psConsume WITH) |> CnvL psSkipEOL
  let (ps3, rules) = parseMatchRules pBlock target ps2
  {Target=target; Rules=rules} |> withPs ps3


/*
  parseIfExpr related
*/


let exprOnlyBlock (expr:Expr) =
   let emp = GoEval<[]Stmt> "[]Stmt{}"
   {Block.Stmts=emp; FinalExpr=expr}
  

/*
parse single expr and return as block.
This is occur like 'if c then XX else YY' oneliner.
*/
let parseInlineBlock (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
   let (ps2, expr) = pExpr ps
   exprOnlyBlock expr
   |> withPs ps2

/*
IF_EXPR = 'if' expr 'then' block (('elif' expr 'then' block)* 'else' block)?

But for elif, this function parse just after if symbol.
*/
let parseIfAfterIfExpr (pExpr:ParseState->ParseState*Expr) (pBlock:ParseState->ParseState*Block) (ps:ParseState) : ParseState*Expr =
  let (ps2, cond) = pExpr ps |> CnvL (psConsume THEN)
  let tgen = psTypeVarGen ps2
  let recurse = parseIfAfterIfExpr pExpr pBlock
  if psCurIs EOL ps2 then
    let (ps3, tbody) = psSkipEOL ps2
                       |> pBlock
    let ps4 = psSkipEOL ps3
    if psCurIs ELSE ps4 then
      let (pse2, fbody) = psConsume ELSE ps4 |> psSkipEOL |> pBlock
      newIfElseCall tgen cond tbody fbody
      |> withPs pse2
    elif psCurIs ELIF ps4 then
      let (ps5, elseExpr) = psConsume ELIF ps4
                           |> recurse
      let ebody = exprOnlyBlock elseExpr
      newIfElseCall tgen cond tbody ebody
      |> withPs ps5
    else
      // if only. use ps before skip eol
      newIfOnlyCall tgen cond tbody
      |> withPs ps3
  else
		// one line case: if COND then TBODY else FBODY
    let (psi2, tbody) = parseInlineBlock pExpr ps2
    if psCurIs ELSE psi2 then
      let (psi3, fbody) = psConsume ELSE psi2 |> parseInlineBlock pExpr
      newIfElseCall tgen cond tbody fbody
      |> withPs psi3
    else
      newIfOnlyCall tgen cond tbody
      |> withPs psi2


/*
IF_EXPR = 'if' expr 'then' block (('elif' expr 'then' block)* 'else' block)?

- expr must bo bool type.
- both block must be the same return type.
- if there is EOL after 'then', it assumue offside block
- if there is no else block, block return type must be unit.
*/
let parseIfExpr (pExpr:ParseState->ParseState*Expr) (pBlock:ParseState->ParseState*Block) (ps:ParseState) : ParseState*Expr =
  psConsume IF ps
  |> parseIfAfterIfExpr pExpr pBlock

let tvgen2ftvgen (tgen:()->TypeVar) =
  tgen () |> FTypeVar


let updateFunCallFunType (tgen:()->TypeVar) (res:Resolver) (vr: VarRef) (args:[]Expr) =
  match vr with
  | VRVar v ->
    match v.Ftype with
    | FFunc _ -> vr // no need to resolve
    | FTypeVar tv ->
      // (f arg0 arg1) and f is TypeVar.
      // We can update to (t0->t1->NewTVar)
      let ntv = tgen () |> FTypeVar
      let nftype = slice.Map ExprToType args
                   |> slice.PushLast ntv
                   |> newFFunc
      // unify v.Ftype to nftype.
      {SrcV=tv.Name; Dest=nftype}
      |> updateResOne res
      {Var.Name=v.Name; Ftype=nftype}
      |> VRVar
  | VRSVar _ -> vr // currently, this case is just NYI.

let parseTerm (pExpr: ParseState->ParseState*Expr) (pBlock: ParseState->ParseState*Block) (ps:ParseState) : ParseState*Expr =
  match psCurrentTT ps with
  | MATCH ->
     parseMatchExpr pExpr pBlock ps
     |> CnvR RMatchExpr |> CnvR EReturnableExpr
  | LSBRACKET -> parseSliceExpr pExpr ps
  | IF -> parseIfExpr pExpr pBlock ps 
  | NOT ->
    let (ps2, target) = psConsume NOT ps |> parseTerm pExpr pBlock
    newUnaryNotCall (psTypeVarGen ps2) target
    |> withPs ps2
  | _ ->
    let (ps2, es) = parseAtomList pExpr ps
    if (slice.Length es) = 1 then
      (ps2, (slice.Head es))
    else
      // funcall
      let head = slice.Head es
      let tail = slice.Tail es
      match head with
      | EVarRef vr ->
        let tgen = psTypeVarGen ps2
        let nvr = updateFunCallFunType tgen ps2.tvc.resolver vr tail
        let fc = {TargetFunc=nvr; Args=tail}
        (ps2, EFunCall fc)
      | _ ->
        frt.Panic "Funcall head is not var"
        (ps2, head)

let lookupBinOpNF (tk:TokenType) =
  let res = lookupBinOp tk
  frt.Fst res

// for recursive call, extract binop later parse.
let parseBinAfter (pEwithMinPrec: int->ParseState->ParseState*Expr) (minPrec: int) (ps:ParseState) (cur:Expr): ParseState*Expr =
  let ps2 = psSkipEOL ps
  if psCurIsBinOp ps2 then
    let btk = psCurrentTT ps2
    let bop = lookupBinOpNF btk
    if bop.Precedence < minPrec then
      (ps, cur)
    else
      let (ps3, rhs) = psConsume btk ps2
                       |> pEwithMinPrec (bop.Precedence+1)
      let tvgen = psTypeVarGen ps3
      newBinOpCall tvgen btk bop cur rhs
      |> parseBinAfter pEwithMinPrec minPrec ps3
  else
    (ps, cur)

/*
EXPR = TERM (BINOP EXPR)*
*/
let parseExprWithPrec (pBlock: ParseState->ParseState*Block) (minPrec: int) (ps:ParseState) : ParseState*Expr =
  let pExpr = parseExprWithPrec pBlock 1
  let (ps2, expr) = parseTerm pExpr pBlock ps
  let ps3 = psSkipEOL ps2
  if psCurIsBinOp ps3 then
    parseBinAfter (parseExprWithPrec pBlock) minPrec ps3 expr
  else
    (ps2, expr)



let parseExpr (pBlock: ParseState->ParseState*Block) (ps:ParseState) : ParseState*Expr =
  parseExprWithPrec pBlock 1 ps

/*
  parseBlock related.
*/

// STMT = LET_STMT | EXPR
let parseStmt (pExpr: ParseState->ParseState*Expr) (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) =
  match psCurrentTT ps with
  | LET ->
    pLet ps |> CnvR SLetVarDef  
  | _ ->
    pExpr ps |> CnvR SExprStmt


let isEndOfBlock (ps:ParseState) =
  let isOffside = (psCurCol ps) < (psCurOffside ps)
  let isEof = (psCurrentTT ps) = EOF
  isOffside || isEof

let parseStmtList (pExpr: ParseState->ParseState*Expr) (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) : ParseState*[]Stmt =
  let (ps2, one) = parseStmt pExpr pLet ps |> CnvL psSkipEOL
  if isEndOfBlock ps2 then
    (ps2, [one])
  else
    parseStmtList pExpr pLet ps2
    |> CnvR (slice.PushHead one)

/*
  BLOCK = EXPR | (STMT_LIKE EOL)* EXPR
  STMT_LIKE = LET_STMT | EXPR

  In some case, we wanto add local variables in block scope,
  in that case, it's handy to pushScope before calling this function.
*/
let parseBlockAfterPushScope (pExpr: ParseState->ParseState*Expr) (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) =
  let (ps2, sls) = psPushOffside ps |> (parseStmtList pExpr pLet) |> CnvL psPopOffside
  let last = slice.Last sls
  let stmts = slice.PopLast sls
  match last with
  | SExprStmt e ->
    (ps2, {Block.Stmts=stmts; FinalExpr=e})
  | _ ->
    frt.Panic "block of last is not expr"
    // dummy
    frt.Empty<Block> ()
    |> withPs ps2

let parseBlock (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) : ParseState*Block =
  let pExpr = parseExpr (parseBlock pLet)
  psPushScope ps |> parseBlockAfterPushScope pExpr pLet

/*
  LL_ONE_VAR_DEF = 'let' IDENTIFIER '=' expr
*/
let parseLLOneVarDef (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, vname) = psConsume LET ps |> psIdentNameNx |> CnvL (psConsume EQ)
  let (ps3, rhs0) = pExpr ps2
  let rhs = InferExpr ps3.tvc rhs0
  let v = {Var.Name=vname; Ftype=(ExprToType rhs)}
  scDefVar ps3.scope vname v
  {LetVarDef.Lvar=v; Rhs=rhs}
  |> LLOneVarDef
  |> withPs ps3


let psIdentOrUSNameNx (ps:ParseState) =
  if psCurIs IDENTIFIER ps then
    psIdentNameNx ps
  else
    let ps2 = psNext ps
    (ps2, "_")

let defVarIfNecessary (sc:Scope) (v:Var) =
  if v.Name <> "_" then
    scDefVar sc v.Name v

/*
  Destructuring, only support pair for a while like:
  let (a, b) = ...

  LL_DEST_VAR_DEF = 'let' '(' IDENTIFIER ',' IDENTIFIER ')' '=' expr
*/
let parseLLDestVarDef (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, vname1) = psConsume LET ps
                     |> psConsume LPAREN
                     |> psIdentOrUSNameNx
                     |> CnvL (psConsume COMMA)
  let (ps3, vname2) = psIdentOrUSNameNx ps2
                     |> CnvL (psConsume RPAREN)
                     |> CnvL (psConsume EQ)
  let (ps4, rhs0) = pExpr ps3
  let rhs = InferExpr ps4.tvc rhs0
  let rtype = ExprToType rhs
  match rtype with
  | FTuple tup ->
    let v1 = {Var.Name=vname1; Ftype= slice.Head tup.ElemTypes}
    let v2 = {Var.Name=vname2; Ftype= slice.Last tup.ElemTypes}
    defVarIfNecessary ps4.scope v1
    defVarIfNecessary ps4.scope v2
    let vs = [v1; v2]
    {LetDestVarDef.Lvars=vs; Rhs=rhs}
    |> LLDestVarDef
    |> withPs ps4
  | FTypeVar _ ->
    // rhs is TypeVar (unresolved), so assign left vars new TypeVar's and resolve later.
    let tpgen = psTypeVarGen ps4
    let vt1 = if vname1 = "_" then
                FUnit // dont't care, use FUnit
              else
                tpgen () |> FTypeVar
    let vt2 = if vname1 = "_" then
                FUnit
              else
                tpgen () |> FTypeVar
    let v1 = {Var.Name=vname1; Ftype=vt1}
    let v2 = {Var.Name=vname2; Ftype=vt2}
    defVarIfNecessary ps4.scope v1
    defVarIfNecessary ps4.scope v2
    let vs = [v1; v2]
    {LetDestVarDef.Lvars=vs; Rhs=rhs}
    |> LLDestVarDef
    |> withPs ps4
  | _ ->
    frt.Panic "Destructuring let, but rhs is not tuple. NYI."
    let dummy = GoEval<[]Var> "[]Var{}"
    (ps2, LLDestVarDef {LetDestVarDef.Lvars=dummy; Rhs=EUnit})

/*
  LET_FUNC_DEF = 'let' IDENTIFIER PARAMS (':' TYPE)? '=' EOL? BLOCK
*/
let parseLetFuncDef (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) =
  let ps2 = psConsume LET ps |> psPushScope
  let fname = psIdentName ps2
  let (ps3, params) = psNext ps2 |> parseParams
  let (ps4, rtypeDef) =  if psCurIs COLON ps3 then
                           psConsume COLON ps3 |> parseType
                         else
                           let tvgen = psTypeVarGen ps3
                           let tvf = tvgen() |> FTypeVar
                           (ps3, tvf) 
  let paramTypes = slice.Map vToT params
  let defTargets = slice.PushLast rtypeDef paramTypes
  let defFt = {FuncType.Targets=defTargets} |> FFunc
  let defVar = {Var.Name=fname; Ftype=defFt}
  scDefVar ps4.scope fname defVar
  let (ps5, block) = psConsume EQ ps4 |> psSkipEOL |> parseBlock pLet |> CnvL psPopScope
  // build lfd func var here for a while.
  let rtype = blockToExpr block |> ExprToType
  let targets = if (slice.Length params) = 0 then
                  [FUnit; rtype]
                else
                  paramTypes
                  |> slice.PushLast rtype
  let ft = {FuncType.Targets=targets} |> FFunc
  let fnvar = {Var.Name=fname; Ftype=ft}
  {Fvar=fnvar; Params=params; Body=block}
  |> withPs ps5

let rfdToFuncFactory (rfd:RootFuncDef) =
  let targets = match rfd.Lfd.Fvar.Ftype with
                | FFunc ft ->
                  ft.Targets
                | _ ->
                  frt.Panic "root func def let with non func var, bug"
                  GoEval<[]FType> "[]FType{}"
  {Tparams=rfd.Tparams; Targets=targets}

let parseRootLetFuncDef (pLet: ParseState->ParseState*LLetVarDef) (ps:ParseState) =
  let (ps2, lfd) = parseLetFuncDef pLet ps
  let rfd = InferLfd ps.tvc lfd
  rfdToFuncFactory rfd |> scRegFunFac ps2.scope rfd.Lfd.Fvar.Name
  (ps2, rfd)

/*
LET_VAR_DEF = LL_ONE_VAR_DEF | LL_DEST_VAR_DEF
*/
let parseLetVarDef (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  let peekPs = psConsume LET ps
  if psCurIs LPAREN peekPs then
    parseLLDestVarDef pExpr ps
  else
    parseLLOneVarDef pExpr ps

/*
  LET = LET_DEST_VAR_DEF | LET_VAR_DEF | LET_FUNC_DEF

  LET_VAR_DEF = 'let' IDENTIFIER '=' expr
  LET_DEST_VAR_DEF = 'let' '(' IDENTIFIER, IDENTIFIER ')' '=' expr
*/
let parseRootLet (pExpr:ParseState->ParseState*Expr) (ps0:ParseState) =
  let ps = psResetTmpCtx ps0
  let pLet = parseLetVarDef pExpr
  let psN = psNext ps
  match psCurrentTT psN with
  | LPAREN ->
    parseRootLetFuncDef pLet ps
    |> CnvR RSRootFuncDef
  | _ ->
    let psNN = psNext psN
    match psCurrentTT psNN with
    | EQ ->
      frt.Panic "Root let var def, NYI"
      (ps, (RSImport "dummy"))
    | _ ->
      parseRootLetFuncDef pLet ps
      |> CnvR RSRootFuncDef
     
/*
  parse RecordDef related.
*/

// FIELD_DEF = ID ':' TYPE
let parseFieldDef (ps:ParseState) =
  let fname = psIdentName ps
  let (ps2, tp) = psNextNOL ps |> psConsume COLON |> parseType
  let ntp = {NameTypePair.Name=fname; Ftype=tp}
  (ps2, ntp)


let parseFieldDefs (ps:ParseState) : ParseState*[]NameTypePair =
  let (ps2, ntp) = psSkipEOL ps |> parseFieldDef
  if (psCurrentTT ps2) = RBRACE then
    (ps2, [ntp])
  else
    let ps3 = psConsume SEMICOLON ps2 |> psSkipEOL
    if psCurIs RBRACE ps3 then
      (ps3, [ntp])
    else
      parseFieldDefs ps3
      |> CnvR (slice.PushHead ntp)


/*
  RECORD_DEF = '{' FIELD_DEFS '}'
  FIELD_DEFS = FIELD_DEF  (';' FIELD_DEF)*
*/
let parseRecordDef (tname:string) (ps:ParseState) =
  let (ps2, ntps) = psConsume LBRACE ps |> parseFieldDefs |> CnvL (psConsume RBRACE)
  let rd = {RecordDef.Name=tname; Fields=ntps}
  // register record typedef.
  psRegRecDefToTDCtx rd ps2
  (ps2, rd)

/*
  parse UnionDef related.
*/

// CASE_DEF = '|' IDENIFIER OF TYPE
let parseOneCaseDef (ps:ParseState) =
  let (ps2, cname) = psConsume BAR ps |> psIdentNameNx
  match psCurrentTT ps2 with
  | OF ->
    let (ps3, tp) = psConsume OF ps2 |> parseType
    let cs = {NameTypePair.Name=cname; Ftype=tp}
    (ps3, cs)
  | _ ->
    // no "of", unit case.
    let ps3 = psConsume EOL ps2
    let cs = {NameTypePair.Name=cname; Ftype=FUnit}
    (ps3, cs)

let parseCaseDefs (ps:ParseState) : ParseState*[]NameTypePair =
  let (ps2, cs) = parseOneCaseDef ps
  let ps3 = psSkipEOL ps2
  if (psCurrentTT ps3) = BAR then
    parseCaseDefs ps3 |> CnvR (slice.PushHead cs)
  else
    (ps2, [cs])

/*
  UNION_DEF = CASE_DEF (EOL CASE_DEF)* EOL
  CASE_DEF = '|' IDENIFIER OF TYPE
*/
let parseUnionDef (tname:string) (ps:ParseState) =
  let (ps2, css) = parseCaseDefs ps
  let ud = {UnionDef.Name=tname; Cases=css}
  psRegUdToTDCtx ud ps2
  (ps2, ud)

let emptyDefStmt () =
  frt.Empty<RecordDef> ()
  |> DRecordDef

/*
  TYPE_DEF_BODY = ID '=' (RECORD_DEF | UNION_DEF)
  RECORD_DEF = '{' FIELD_DEFS '}'
  UNION_DEF = '|'...
*/
let parseTypeDefBody (ps:ParseState) = 
  let (ps2, tname) = psIdentNameNxL ps |> CnvL (psConsume EQ) |> CnvL psSkipEOL
  match psCurrentTT ps2 with
  | LBRACE ->
    parseRecordDef tname ps2 |> CnvR DRecordDef
  | BAR ->
    parseUnionDef tname ps2  |> CnvR DUnionDef
  | _ ->
    frt.Panic "NYI"
    (ps2, (emptyDefStmt ()))

/*
  TYPE_DEF_BODY_LIST = TYPE_DEF_BODY ('and' TYPE_DEF_BODY)*
*/
let parseTypeDefBodyList (ps:ParseState) : ParseState*[]DefStmt =
  let (ps2, df) = parseTypeDefBody ps |> CnvL psSkipEOL
  if psCurIs AND ps2 then
    psConsume AND ps2
    |> parseTypeDefBodyList
    |> CnvR (slice.PushHead df)
  else
    (ps2, [df])

//  
// TYPE_DEF = 'type' TYPE_DEF_BODY_LIST
let parseTypeDef (ps:ParseState) =
  let (ps2, defList) = psEnterTypeDef ps |> psPushScope |> psConsume TYPE |> parseTypeDefBodyList |> CnvL psPopScope |> CnvL psLeaveTypeDef
  let mdefs = {Defs=defList}
  let nmdefs = resolveFwrdDecl mdefs ps2
  psRegMdTypes nmdefs ps2
  nmdefs
  |> RSMultipleDefs
  |> withPs ps2

/*
  PackageInfo related:
*/

/*
  ID_LIST = IDENTIFIER (',' IDENTIFIER)*
*/
let parseIdList (ps:ParseState) : ParseState*[]string =
  let (ps2, tname) = psIdentNameNx ps
  if (psCurrentTT ps2) = COMMA then
    psConsume COMMA ps2
    |> parseIdList
    |> CnvR (slice.PushHead tname)
  else
    (ps2, [tname])


/*
  if '<' ID_LIST '>', return ID_LIST as []string
  else return empty []string.
*/
let mightParseIdList (ps:ParseState) =
  if psCurIs LT ps then
    psConsume LT ps
    |> parseIdList
    |> CnvL (psConsume GT)
  else
    GoEval<[]string> "[]string{}"
    |>withPs ps
    

/*
  EXT_TYPE_DEF = 'type' IDENTIFIER ('<' IDENTIFIER_LIST '>')?
*/
let parseExtTypeDef (pi:PackageInfo) (ps:ParseState) =
  let (ps2, tname) = psConsume TYPE ps |> psIdentNameNx
  let (ps3, pnames) = mightParseIdList ps2
  let tfd = piRegEType pi tname pnames
  scRegTFData ps3.scope tname tfd
  ps3


let regTypeVar (ps:ParseState) (tname:string) =
  FTypeVar {TypeVar.Name=tname}
  |> scRegisterType ps.scope tname

let psRegTypeVars (ps:ParseState) (tnames:[]string) =
  slice.Iter (regTypeVar ps) tnames

/*
  EXT_FUNC_DEF = 'let' IDENTIFIER (TYPE_PARAM)? ':' FUNC_TYPE
*/
let parseExtFuncDef (pi:PackageInfo) (ps:ParseState) =
  let (ps2, fname) = psConsume LET ps |> psIdentNameNx
  let (ps3, tnames) = mightParseIdList ps2
  psRegTypeVars ps3 tnames
  let (ps4, fts) = psConsume COLON ps3
                   |> parseTypeArrows parseType
  let ff = {Tparams=tnames; Targets=fts}
  piRegFF pi fname ff ps4
  ps4

let parseExtDef (pi:PackageInfo) (ps:ParseState) =
  match (psCurrentTT ps) with
  | LET -> parseExtFuncDef pi ps
  | TYPE -> parseExtTypeDef pi ps
  | _ ->
    frt.Panic "Unknown pkginfo def"
    ps

let parseExtDefs (pi:PackageInfo) (ps:ParseState) : ParseState =
   let ps2 = parseExtDef pi ps |> psSkipEOL
   if isEndOfBlock ps2 then
     ps2
   else
     parseExtDefs pi ps2

/*
  PACKAGE_INFO = 'package_info' IDENTIFIER '=' EOL (OFFSIDE EXT_DEF EOL)*
  EXT_DEF = (EXT_TYPE_DEF|EXT_FUNC_DEF)
*/
let parsePackageInfo (ps:ParseState) =
  let ps2 = psConsume PACKAGE_INFO ps
  let (ps3, pkgName) = if (psCurrentTT ps2) = UNDER_SCORE then
                         (ps2, "_")
                         |> CnvL psNext
                       else
                         psIdentNameNx ps2
  let ps4 = psConsume EQ ps3
            |> psSkipEOL
            |> psPushOffside
            |> psPushScope
  let pi = NewPackageInfo pkgName
  let ps5 = parseExtDefs pi ps4
            |> psPopScope
            |> psPopOffside
  piRegAll pi ps5.scope
  (ps5, (RSPackageInfo pi))

/*
  parse Stmt related.
*/

let parseRootOneStmt (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  match psCurrentTT ps with
  | PACKAGE -> parsePackage ps
  | IMPORT -> parseImport ps
  | LET -> parseRootLet pExpr ps
  | TYPE -> parseTypeDef ps
  | PACKAGE_INFO -> parsePackageInfo ps
  | _ ->
    frt.Panic "Unknown stmt"
    parsePackage ps // never reached this line.

let parseRootOneStmtSk (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  parseRootOneStmt pExpr ps
  |> CnvL psSkipEOL

let psIsRootStmtsEnd (ps:ParseState) =
  (psCurrentTT ps) = EOF

// this recursive is too deep for golang.
let parseRootStmts (pExpr: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]RootStmt =
  psSkipEOL ps
  |> ParseList (parseRootOneStmtSk pExpr) psIsRootStmtsEnd

