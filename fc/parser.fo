package main

import frt
import slice

let parsePackage (ps:ParseState) =
  psConsume PACKAGE ps
  |> psIdentNameNxL
  |> CnvR RSPackage

let parseImport (ps:ParseState) =
  psConsume IMPORT ps
  |> psStringValNxL
  |> CnvR RSImport

/*
  ATOM_TYPE = 'string' | 'int' | '(' ')' | REGISTERED_TYPE | '[' ']' TERM_TYPE | '(' TYPE ')'
*/
let parseAtomType (pType:ParseState->ParseState*FType) (pTerm:ParseState->ParseState*FType) (ps:ParseState) =
  let tk = psCurrent ps
  match tk.ttype with
  | LPAREN ->
    let ps2 = psConsume LPAREN ps
    if (psCurrentTT ps2) = RPAREN then
      let ps3 = psConsume RPAREN ps2
      (ps3, FUnit)
    else
      pType ps2
      |> CnvL (psConsume RPAREN)
  | LSBRACKET ->
    let (ps2, et) = psConsume LSBRACKET ps
                    |> psConsume RSBRACKET
                    |> pTerm
    {SliceType.elemType=et}
    |> FSlice
    |> withPs ps2
  | IDENTIFIER ->
    let tname = tk.stringVal
    let ps3 = psNext ps
    let rtype = if tname = "string" then
                  FString
                elif tname = "int" then
                  FInt
                elif tname = "bool" then
                  FBool
                else
                  let (res, ok) = scLookupType ps3.scope tname
                  if ok then
                    res
                  else
                    frt.Panic("type not found.")
                    FUnit
    (ps3, rtype)
  | _ ->
    frt.Panic("Unknown type")
    (ps, FUnit)

let parseTermType (pType:ParseState->ParseState*FType) (ps:ParseState) : ParseState*FType =
  parseAtomType pType (parseTermType pType) ps

/*
  TYPE_ARROWS = TERM_TYPE ('->' TERM_TYPE)*

  return []FType
*/
let parseTypeArrows (pType:ParseState->ParseState*FType) (ps:ParseState) : ParseState*[]FType =
  let (ps2, one) = parseTermType pType ps
  if (psCurrentTT ps2) = RARROW then
    psConsume RARROW ps2
    |> parseTypeArrows pType
    |> CnvR (slice.PushHead one)
  else
    (ps2, [one])

/*
  TYPE =  TERM_TYPE | FUNC_TYPE
*/
let parseType (ps:ParseState) : ParseState*FType =
  let (ps2, tps) = parseTypeArrows parseType ps
  if (slice.Length tps) = 1 then
    slice.Head tps |> withPs ps2
  else
    FFunc {FuncType.targets=tps}
    |> withPs ps2

type Param =
| PVar of Var
| PUnit

/*
	PARAM = '(' ')'
				|	'(' IDENTIFIER : TYPE ')'
*/
let parseParam (ps:ParseState) =
  let ps2 = psConsume LPAREN ps
  let tk = psCurrent ps2
  match tk.ttype with
  | RPAREN ->
     let ps3 = psConsume RPAREN ps2
     (ps3, PUnit)
  | _ ->
    let vname = psIdentName ps2
    let (ps3, tp) = psNext ps2
                    |> psConsume COLON
                    |> parseType
                    |> CnvL (psConsume RPAREN)
    let v = {Var.name=vname; ftype=tp}
    scDefVar ps3.scope vname v
    (ps3, (PVar v))

let parseParams (ps:ParseState) : ParseState*[]Var =
  let (ps2, prm1) = parseParam ps
  match prm1 with
  | PUnit ->
      let zero = GoEval<[]Var> "[]Var{}"
      (ps2, zero)
  | PVar v ->
      let tt = psCurrentTT ps2
      match tt with
      | LPAREN ->
        parseParams ps2
        |> CnvR (slice.PushLast v)
      | _ -> (ps2, [v])

/*
  GO_EVAL = 'GoEval' string | 'GoEval' '<' TYPE '>' string

  It should not have space between 'GoEval' and '<' though currently we just don't care those differences.
*/
let parseGoEval (ps:ParseState) =
  let ps2 = psNext ps
  match psCurrentTT ps2 with
  | LT ->
    let (ps3, ft) = psConsume LT ps2 |> parseType |> CnvL (psConsume GT)
    let (ps4, s) = psStringValNx ps3
    let ge = {goStmt=s; typeArg=ft}
    (ps4, EGoEvalExpr ge)
  | STRING ->
    let (ps3, s) = psStringValNx ps2
    let ge = {goStmt=s; typeArg=FUnit}
    (ps3, EGoEvalExpr ge)
  | _ ->
    frt.Panic "Wrong arg for GoEval"
    (ps2, EUnit)


// FIELD_INITIALIZER = IDENTIFIER '=' expr
let parseFiIni (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let fname = psIdentName ps
  let (ps2, expr) = psNextNOL ps |> psConsume EQ |> psSkipEOL |> parseE
  (ps2, {name=fname;expr=expr})


let parseFieldInitializers (parseE: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]NEPair =
  let (ps2, nep) = parseFiIni parseE ps
  if (psCurrentTT ps2) = RBRACE then
    (ps2, [nep])
  else
    psConsume SEMICOLON ps2
    |> parseFieldInitializers parseE
    |> CnvR (slice.PushHead nep)

let NVPToName (nvp:NEPair) =
  nvp.name

/*
  RECORD_EXPRESISONN = '{' FIELD_INITIALIZERS '}'
  FIELD_INITIALIZERS = FIELD_INITIALIZER (';' FIELD_INITIALIZER)*
  FIELD_INITIALIZER = IDENTIFIER '=' expr
*/
let parseRecordGen (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, neps) = psConsume LBRACE ps |> parseFieldInitializers parseE |> CnvL (psConsume RBRACE)
  let (rtype, ok) = slice.Map NVPToName neps |> scLookupRecord ps2.scope
  if ok then
    {fieldsNV=neps; recordType=rtype}
    |> ERecordGen |> withPs ps2
  else
    frt.Panic "record field name match to no record type."
    (ps2, EUnit)

let refVar (vname:string) (ps:ParseState) =
  let (vfac, ok) = scLookupVarFac ps.scope vname
  if ok then
    psTypeVarGen ps |> vfac |> EVar
  else
    frt.Panic "Unknown var ref"
    EUnit

let parseFullName (ps:ParseState) : ParseState*string =
   let (ps2, one) = psIdentNameNx ps
   if (psCurrentTT ps2) = DOT then
     let (ps3, rest) = psConsume DOT ps2 |> parseFullName
     (ps3, (one + "." + rest))
   else
     (ps2, one)

/*
  VARIABLE_REF = IDENTIFIER | IDENTIFER '.' IDENTIFIER

  For first case, IDENTIFIER must be in scope.
  For later case, there are 2 types:
    - external pkg access: slice.Take
    - record field access: rec.Person
*/
let parseVarRef (ps:ParseState) =
  let (ps2, firstId) = psIdentNameNx ps
  if (psCurrentTT ps2) <> DOT then
    refVar firstId ps2
    |> withPs ps2
  else
  	// Next is dot. Check whether rec field access or pkg access.
    // NYI
    /*
    let (v, ok) = scLookupVar ps2.scope firstId
    if ok then
  		// symbol found, record field access.
    */
    //
    // external pkg access.
    // use original ps for parseFullName
    let (ps3, fullName) = parseFullName ps
    refVar fullName ps3
    |> withPs ps3


let parseAtom (parseE: ParseState->ParseState*Expr) (ps:ParseState) =
  let cur = psCurrent ps
  let pn = psNext ps
  match cur.ttype with
  | STRING ->
    EStringLiteral cur.stringVal |> withPs pn
  | INT_IMM ->
    EIntImm cur.intVal |> withPs pn
  | TRUE ->
    EBoolLiteral true |> withPs pn
  | FALSE ->
    EBoolLiteral false |> withPs pn
  | LBRACE ->
    parseRecordGen parseE ps
  | LPAREN ->
    if (psCurrentTT pn) = RPAREN then
      (pn, EUnit) |> CnvL (psConsume RPAREN)
    else
      parseE pn |> CnvL (psConsume RPAREN)
  | IDENTIFIER ->
    if cur.stringVal = "GoEval" then
      parseGoEval ps
    else
      parseVarRef ps
  | _ ->
    frt.Panic "Unown atom."
    (ps, EUnit)


let isEndOfTerm (ps:ParseState) =
  match psCurrentTT ps with
  | EOF -> true
  | EOL -> true
  | SEMICOLON -> true
  | RBRACE -> true
  | RPAREN -> true
  | RSBRACKET -> true
  | WITH -> true
  | THEN -> true
  | ELSE -> true
  | COMMA -> true
  | _ -> false

let parseAtomList (parseE: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]Expr =
  let (ps2, one) = parseAtom parseE ps
  if isEndOfTerm ps2 then
    (ps2, [one])
  else
    parseAtomList parseE ps2
    |> CnvR (slice.PushHead one)


/*
  MATCH_RULE = '|' IDENTIFIER IDENTIFIER '->' BLOCK
            |  '|' '_' '->' BLOCK

ex:
	| Record r -> hoge r
  | _-> ""
*/
let parseMatchRule (pBlock: ParseState->ParseState*Block) (target:Expr) (ps:ParseState) =
  let ps2 = psConsume BAR ps
  match psCurrentTT ps2 with
  | UNDER_SCORE -> // default case
    let (ps3, block) = psConsume UNDER_SCORE ps2
                      |> psConsume RARROW
                      |> psSkipEOL
                      |> pBlock
    //  return &MatchRule{&MatchPattern{"_", ""}, block}
    let mp = {caseId="_"; varName=""}
    {pattern=mp; body=block}
    |> withPs ps3
  | _ -> // normal case
    let (ps3, cname) = psIdentNameNx ps2
    let (ps4, vname) = match (psCurrentTT ps3) with
                        | RARROW ->
                          // no content case. use "".
                          (ps3, "")
                        | UNDER_SCORE ->
                          (ps3, "_") |> CnvL psNext
                        | _ ->
                           psIdentNameNx ps3
    let ps5 = psConsume RARROW ps4 |> psSkipEOL |> psPushScope
    if vname <> "" && vname <> "_" then
      let tt = ExprToType target
      // currently, match expect union type
      let fu = GoEval<UnionType> "tt.(FType_FUnion).Value"
      let cp = lookupCase fu cname
      scDefVar ps5.scope vname {Var.name=vname; ftype=cp.ftype}
    let (ps6, block) = pBlock ps5
    let mp = {caseId=cname; varName=vname}
    {pattern=mp; body=block}
    |> withPs ps6

let parseMatchRules (pBlock: ParseState->ParseState*Block) (target:Expr) (ps:ParseState) : []MatchRule =
  let (ps2, one) = parseMatchRule pBlock target ps |> CnvL psSkipEOL
  if (psCurrentTT ps2) = BAR then
    parseMatchRules pBlock target ps2 |> CnvR (slice.PushHead one)
  else
    (ps2, [one])

/*
  MATCH_EXPR = 'match' EXPR 'with' EOL MATCH_RULE+
*/
let parseMatchExpr (pExpr: ParseState->ParseState*Expr) (pBlock: ParseState->ParseState*Block) (ps:ParseState) =
  let (ps2, target) = psConsume MATCH ps |> pExpr |> CnvL (psConsume WITH) |> CnvL psSkipEOL
  let (ps3, rules) = parseMatchRules pBlock target ps2
  {target=target; rules=rules} |> withPs ps3

// expr (; expr)*
let parseSemiExprs (pExpr: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]Expr =
  let (ps2, one) = pExpr ps
  if (psCurrentTT ps2) = SEMICOLON then
    psConsume SEMICOLON ps2
    |> parseSemiExprs pExpr
    |> CnvR (slice.PushHead one)
  else
    (ps2, [one])

/*
  SLICE_EXPR = '[' expr (; expr)* ']'
*/
let parseSliceExpr (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
   psConsume LSBRACKET ps
   |> parseSemiExprs pExpr
   |> CnvL (psConsume RSBRACKET)
   |> CnvR ESlice

let parseTerm (pBlock: ParseState->ParseState*Block) (ps:ParseState) : ParseState*Expr =
  let pExpr = parseTerm pBlock
  match psCurrentTT ps with
  | MATCH ->
     parseMatchExpr pExpr pBlock ps
     |> CnvR RMatchExpr |> CnvR EReturnableExpr
  | LSBRACKET -> parseSliceExpr pExpr ps
  | _ ->
    let (ps2, es) = parseAtomList pExpr ps
    if (slice.Length es) = 1 then
      (ps2, (slice.Head es))
    else
      // funcall
      let head = slice.Head es
      let tail = slice.Tail es
      match head with
      | EVar v ->
        let fc = {targetFunc=v; args=tail}
        (ps2, EFunCall fc)
      | _ ->
        frt.Panic "Funcall head is not var"
        (ps2, head)

/*
  parseBlock related.
*/

// STMT = LET_STMT | EXPR
let parseStmt (pExpr: ParseState->ParseState*Expr) (pLet: ParseState->ParseState*LetVarDef) (ps:ParseState) =
  match psCurrentTT ps with
  | LET ->
    pLet ps |> CnvR SLetVarDef
  | _ ->
    pExpr ps |> CnvR SExprStmt


let isEndOfBlock (ps:ParseState) =
  let isOffside = (psCurCol ps) < (psCurOffside ps)
  let isEof = (psCurrentTT ps) = EOF
  isOffside || isEof

let parseStmtList (pExpr: ParseState->ParseState*Expr) (pLet: ParseState->ParseState*LetVarDef) (ps:ParseState) : []Stmt =
  let (ps2, one) = parseStmt pExpr pLet ps |> CnvL psSkipEOL
  if isEndOfBlock ps2 then
    (ps2, [one])
  else
    parseStmtList pExpr pLet ps2
    |> CnvR (slice.PushHead one)

// for dummy usage
let emptyBlock () =
  GoEval<Block> "Block{}"

/*
  BLOCK = EXPR | (STMT_LIKE EOL)* EXPR
  STMT_LIKE = LET_STMT | EXPR

  In some case, we wanto add local variables in block scope,
  in that case, it's handy to pushScope before calling this function.
*/
let parseBlockAfterPushScope (pExpr: ParseState->ParseState*Expr) (pLet: ParseState->ParseState*LetVarDef) (ps:ParseState) =
  let (ps2, sls) = psPushOffside ps |> (parseStmtList pExpr pLet) |> CnvL psPopOffside
  let last = slice.Last sls
  let stmts = slice.PopLast sls
  match last with
  | SExprStmt e ->
    (ps2, {Block.stmts=stmts; finalExpr=e})
  | _ ->
    frt.Panic "block of last is not expr"
    // dummy
    emptyBlock ()
    |> withPs ps2

let parseBlock (pLet: ParseState->ParseState*LetVarDef) (ps:ParseState) : ParseState*Block =
  let pExpr = parseTerm (parseBlock pLet)
  psPushScope ps |> parseBlockAfterPushScope pExpr pLet

/*
  LET_VAR_DEF = 'let' IDENTIFIER '=' expr
*/
let parseLetVarDef (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  let (ps2, vname) = psConsume LET ps |> psIdentNameNx |> CnvL (psConsume EQ)
  let (ps3, rhs) = pExpr ps2
  let v = {Var.name=vname; ftype=(ExprToType rhs)}
  scDefVar ps3.scope vname v
  {LetVarDef.name=vname; rhs=rhs}
  |> withPs ps3

let vToT (v:Var) =
  v.ftype

// FFunc of FuncType
// FuncType = {targets: []FType}
// LetFuncDef = {name: string; params: []Var; body:Block}
let lfdToFuncType (lfd:LetFuncDef) =
  let rtype = blockToExpr lfd.body |> ExprToType
  let targets = slice.Map vToT lfd.params |> slice.PushLast rtype
  {FuncType.targets=targets}

// I want to make this func as factory.
// But currently, last arg () is not supported.
// So I return Var here and handle in wrapper.go for a while.
let lfdToFuncVar (lfd:LetFuncDef) =
  let ft = lfdToFuncType lfd |> FFunc
  {Var.name=lfd.name; ftype=ft}

/*
  LET_FUNC_DEF = 'let' IDENTIFIER PARAMS (':' TYPE)? '=' EOL? BLOCK
*/
let parseLetFuncDef (pLet: ParseState->ParseState*LetVarDef) (ps:ParseState) =
  let ps2 = psConsume LET ps
  let fname = psIdentName ps2
  let (ps3, params) = psNext ps2 |> parseParams
  // TODO: put current func for recursive call.
  let (ps4, block) = psConsume EQ ps3 |> psSkipEOL |> parseBlock pLet
  {LetFuncDef.name=fname; params=params; body=block}
  |> withPs ps4

let parseRootLetFuncDef (pLet: ParseState->ParseState*LetVarDef) (ps:ParseState) =
  let (ps2, lfd) = parseLetFuncDef pLet ps
  // resolve lfd here.
  lfdToFuncVar lfd |> scDefVar ps.scope lfd.name 
  (ps2, lfd)

/*
  LET = LET_DEST_VAR_DEF | LET_VAR_DEF | LET_FUNC_DEF

  LET_VAR_DEF = 'let' IDENTIFIER '=' expr
  LET_DEST_VAR_DEF = 'let' '(' IDENTIFIER, IDENTIFIER ')' '=' expr
*/
let parseRootLet (pExpr:ParseState->ParseState*Expr) (ps0:ParseState) =
  let ps = psResetTmpCtx ps0
  let pLet = parseLetVarDef pExpr
  let psN = psNext ps
  match psCurrentTT psN with
  | LPAREN ->
    parseRootLetFuncDef pLet ps
    |> CnvR RSLetFuncDef
  | _ ->
    let psNN = psNext psN
    match psCurrentTT psNN with
    | EQ ->
      frt.Panic "Root let var def, NYI"
      (ps, (RSImport "dummy"))
    | _ ->
      parseRootLetFuncDef pLet ps
      |> CnvR RSLetFuncDef
     
/*
  parse RecordDef related.
*/

// FIELD_DEF = ID ':' TYPE
let parseFieldDef (ps:ParseState) =
  let fname = psIdentName ps
  let (ps2, tp) = psNextNOL ps |> psConsume COLON |> parseType
  let ntp = {NameTypePair.name=fname; ftype=tp}
  (ps2, ntp)


let parseFieldDefs (ps:ParseState) : ParseState*[]NameTypePair =
  let (ps2, ntp) = parseFieldDef ps
  if (psCurrentTT ps2) = RBRACE then
    (ps2, [ntp])
  else
    psConsume SEMICOLON ps2
    |> parseFieldDefs
    |> CnvR (slice.PushHead ntp)

let rdToRecType (rd:RecordDef) =
  // golang complaint:
  // S1016 - Use a type conversion instead of manually copying struct fields 
  // {RecordType.name=rd.name; fields=rd.fields}
  GoEval<RecordType> "RecordType(rd)"

/*
  RECORD_DEF = '{' FIELD_DEFS '}'
  FIELD_DEFS = FIELD_DEF  (';' FIELD_DEF)*
*/
let parseRecordDef (tname:string) (ps:ParseState) =
  let (ps2, ntps) = psConsume LBRACE ps |> parseFieldDefs |> CnvL (psConsume RBRACE)
  let rd = {RecordDef.name=tname; fields=ntps}
  // register record typedef.
  rdToRecType rd |> scRegisterRecType ps2.scope
  (ps2, rd)

/*
  parse UnionDef related.
*/

// CASE_DEF = '|' IDENIFIER OF TYPE
let parseOneCaseDef (ps:ParseState) =
  let (ps2, cname) = psConsume BAR ps |> psIdentNameNx
  match psCurrentTT ps2 with
  | OF ->
    let (ps3, tp) = psConsume OF ps2 |> parseType
    let cs = {NameTypePair.name=cname; ftype=tp}
    (ps3, cs)
  | _ ->
    // no "of", unit case.
    let ps3 = psConsume EOL ps2
    let cs = {NameTypePair.name=cname; ftype=FUnit}
    (ps3, cs)

let parseCaseDefs (ps:ParseState) : []NameTypePair =
  let (ps2, cs) = parseOneCaseDef ps
  let ps3 = psSkipEOL ps2
  if (psCurrentTT ps3) = BAR then
    parseCaseDefs ps3 |> CnvR (slice.PushHead cs)
  else
    (ps2, [cs])

/*
  UNION_DEF = CASE_DEF (EOL CASE_DEF)* EOL
  CASE_DEF = '|' IDENIFIER OF TYPE
*/
let parseUnionDef (tname:string) (ps:ParseState) =
  let (ps2, css) = parseCaseDefs ps
  let ud = {UnionDef.name=tname; cases=css}
  udRegisterToScope ps2.scope ud
  (ps2, ud)
  

// TYPE_DEF = 'type' ID '=' (RECORD_DEF | UNION_DEF)
//
// RECORD_DEF = '{' FIELD_DEFS '}'
//
// UNION_DEF = '|'...
let parseTypeDef (ps:ParseState) =
  let (ps2, tname) = psConsume TYPE ps |> psIdentNameNxL |> CnvL (psConsume EQ) |> CnvL psSkipEOL
  match psCurrentTT ps2 with
  | LBRACE ->
    parseRecordDef tname ps2 |> CnvR DRecordDef |> CnvR RSDefStmt
  | BAR ->
    parseUnionDef tname ps2  |> CnvR DUnionDef |> CnvR RSDefStmt
  | _ ->
    frt.Panic "NYI"
    (ps2, (RSImport "dummy"))

/*
  PackageInfo related:
*/

/*
  EXT_TYPE_DEF = 'type' IDENTIFIER
*/
let parseExtTypeDef (pi:PackageInfo) (ps:ParseState) =
  let (ps2, tname) = psConsume TYPE ps |> psIdentNameNx
  let etype = piRegEType pi tname
  scRegisterType ps2.scope tname etype
  ps2

/*
  TYPE_PARAMS = '<' IDENTIFIER (',' IDENTIFIER)* '>'

  call this function after consume '<'
*/
let parseTypeParams (ps:ParseState) : ParseState*[]string =
  let (ps2, tname) = psIdentNameNx ps
  if (psCurrentTT ps2) = COMMA then
    psConsume COMMA ps2
    |> parseTypeParams
    |> CnvR (slice.PushHead tname)
  else
    (ps2, [tname])

let regTypeVar (ps:ParseState) (tname:string) =
  FTypeVar {TypeVar.name=tname}
  |> scRegisterType ps.scope tname

let psRegTypeVars (ps:ParseState) (tnames:[]string) =
  slice.Iter (regTypeVar ps) tnames

/*
  EXT_FUNC_DEF = 'let' IDENTIFIER (TYPE_PARAM)? ':' FUNC_TYPE
*/
let parseExtFuncDef (pi:PackageInfo) (ps:ParseState) =
  let (ps2, fname) = psConsume LET ps |> psIdentNameNx
  let (ps3, tnames) = if (psCurrentTT ps2) = LT then
                        psConsume LT ps2
                        |> parseTypeParams
                        |> CnvL (psConsume GT)
                      else
                        GoEval<[]string> "[]string{}"
                        |>withPs ps2            
  psRegTypeVars ps3 tnames
  let (ps4, fts) = psConsume COLON ps3
                   |> parseTypeArrows parseType
  let ff = {tparams=tnames; targets=fts}
  piRegFF pi fname ff ps4
  ps4

let parseExtDef (pi:PackageInfo) (ps:ParseState) =
  match (psCurrentTT ps) with
  | LET -> parseExtFuncDef pi ps
  | TYPE -> parseExtTypeDef pi ps
  | _ ->
    frt.Panic "Unknown pkginfo def"
    ps

let parseExtDefs (pi:PackageInfo) (ps:ParseState) : ParseState =
   let ps2 = parseExtDef pi ps |> psSkipEOL
   if isEndOfBlock ps2 then
     ps2
   else
     parseExtDefs pi ps2

/*
  PACKAGE_INFO = 'package_info' IDENTIFIER '=' EOL (OFFSIDE EXT_DEF EOL)*
  EXT_DEF = (EXT_TYPE_DEF|EXT_FUNC_DEF)
*/
let parsePackageInfo (ps:ParseState) =
  let ps2 = psConsume PACKAGE_INFO ps
  let (ps3, pkgName) = if (psCurrentTT ps2) = UNDER_SCORE then
                         (ps2, "_")
                         |> CnvL psNext
                       else
                         psIdentNameNx ps2
  let ps4 = psConsume EQ ps3
            |> psSkipEOL
            |> psPushOffside
            |> psPushScope
  let pi = NewPackageInfo pkgName
  let ps5 = parseExtDefs pi ps4
            |> psPopScope
            |> psPopOffside
  piRegAll pi ps5.scope
  (ps5, (RSPackageInfo pi))

/*
  parse Stmt related.
*/

let parseRootOneStmt (pExpr: ParseState->ParseState*Expr) (ps:ParseState) =
  match psCurrentTT ps with
  | PACKAGE -> parsePackage ps
  | IMPORT -> parseImport ps
  | LET -> parseRootLet pExpr ps
  | TYPE -> parseTypeDef ps
  | PACKAGE_INFO -> parsePackageInfo ps
  | _ ->
    frt.Panic "Unknown stmt"
    parsePackage ps // never reached this line.

let parseRootStmts (pExpr: ParseState->ParseState*Expr) (ps:ParseState) : ParseState*[]RootStmt =
  let ps2 = psSkipEOL ps
  if (psCurrentTT ps2) = EOF then
    let s = GoEval<[]RootStmt> "[]RootStmt{}"
    (ps2, s)
  else
    let (ps3, one) = parseRootOneStmt pExpr ps2 |> CnvL psSkipEOL
    let (ps4, rest) = parseRootStmts pExpr ps3
    let ss = slice.PushHead one rest
    (ps4, ss)
