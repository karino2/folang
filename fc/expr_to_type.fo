package main

import frt
import slice

let faToType (fa:FieldAccess) =
  let rt = fa.targetType
  let field = frGetField rt fa.fieldName
  field.ftype

let lblockReturnType (toT: Expr->FType) (lb:LazyBlock) =
  toT lb.finalExpr

let lblockToType (toT: Expr->FType)  (lb:LazyBlock)=
  let rtype = lblockReturnType toT lb
  FFunc {targets=[FUnit; rtype]}

let blockReturnType (toT: Expr->FType) (block:Block) =
  toT block.finalExpr

let blockToType (toT: Expr->FType)  (b:Block)=
  blockReturnType toT b

let blockToExpr (block:Block) =
  EReturnableExpr (RBlock block)

let meToType (toT: Expr->FType) (me:MatchExpr) =
  let frule = me.rules |> slice.Head
  frule.body |> blockToExpr |> toT

let returnableToType (toT: Expr->FType) (rexpr:ReturnableExpr)  : FType =
  match rexpr with
  | RBlock b -> blockToType toT b
  | RMatchExpr me -> meToType toT me

let fcToFuncType (fc:FunCall) =
  // double field access like fc.targetFunc.ftype is NYI.
  let tfv = fc.targetFunc
  let ft = tfv.ftype
  match ft with
  | FFunc ft -> ft
  | _ -> GoEval<FuncType> "FuncType{}" // never happens.


let fcToType (fc:FunCall) =
  let ft = fcToFuncType fc
  let tlen = fargs ft |> slice.Length
  let alen = slice.Length fc.args
  if alen = tlen then
    freturn ft
  else
    // prtial apply.
    GoEval "if alen > tlen { panic(\"too many arugments\")}"
    let newts = slice.Skip alen ft.targets
    FFunc {targets=newts}

let ExprToType (expr:Expr) : FType =
  match expr with
  | EGoEvalExpr ge -> ge.typeArg
  | EStringLiteral _ -> FString
  | EIntImm _ -> FInt
  | EUnit -> FUnit
  | EBoolLiteral _ -> FBool
  | EFieldAccess fa -> faToType fa
  | EVar v -> v.ftype
  | ESlice s -> 
    // slice must be all the same type, so use first elem type.
    let etp = slice.Head s |> ExprToType
    let st = {SliceType.elemType=etp}
    FSlice st
  | ERecordGen rg -> FRecord rg.recordType
  | ELazyBlock lb -> lblockToType ExprToType lb
  | EReturnableExpr re -> returnableToType ExprToType re
  | EFunCall fc -> fcToType fc
