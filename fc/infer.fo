package main

import frt
import slice

/*
  UniRel collection.
*/

// src VarType and dest FType has unique constraints.
// If both are VarType, src is alphabetically later order (to avoid cyclic reference to later stage).
type UniRel = {srcV:string; dest: FType}

let emptyRels () =
  GoEval<[]UniRel> "[]UniRel{}"

// generics it NYI...
let tupApply (f:FType->FType->FType*[]UniRel) (tup:FType*FType) =
  let (lhs, rhs) = tup
  f lhs rhs

let withRels (rels:[]UniRel) (tp:FType) =
  (tp, rels)

let withTp (tp:FType) (rels:[]UniRel) =
  (tp, rels)


/*
  compare two type and adopt concrete one.
  
  tp1: int->T1->[]string
  tp2: int->int->[]T2

  result type is: int->int->[]string
  unirel is: [{T1->int}; {T2->string}]

  If you just need unirel, just discard result type. 
*/
let compositeTp (lhs:FType) (rhs:FType) : FType*[]UniRel =
  match lhs with
  | FTypeVar tv ->
    match rhs with
    | FTypeVar tv2 ->
      // same typevar
      if tv.name = tv2.name then        
        emptyRels ()
        |> withTp lhs
      elif tv.name > tv2.name then
        // keep alphabetically later one to src.
        [{srcV=tv.name; dest=rhs}]
        |> withTp rhs
      else
        [{srcV=tv2.name;dest=lhs}]
        |> withTp lhs
    | _ ->
      [{srcV=tv.name; dest=rhs}]
      |> withTp rhs
  | _ ->
    match rhs with
    | FTypeVar tv2 ->
      [{srcV=tv2.name; dest=lhs}]
      |> withTp lhs
    // Both are not FTypeVar, drill down.
    // Both type must be equal for this layer.
    | FSlice ts2 ->
      let ts1 = GoEval<SliceType> "lhs.(FType_FSlice).Value"
      let (rtp, rels) = compositeTp ts1.elemType ts2.elemType
      {SliceType.elemType=rtp}
      |> FSlice
      |> withRels rels      
    | FFunc tf2 ->
      let tf1 = GoEval<FuncType> "lhs.(FType_FFunc).Value"
      // [](type*[]UniRel)
      let tups = slice.Zip tf1.targets tf2.targets
                 |> slice.Map (tupApply compositeTp)
      let tps = slice.Map frt.Fst tups
      let rels = tups |> slice.Map frt.Snd |> slice.Concat
      {FuncType.targets=tps}
      |> FFunc
      |> withRels rels
    | _ ->
      // both type is concrete.
      emptyRels ()
      |> withTp lhs


let unifyType (lhs:FType) (rhs:FType) : []UniRel =
  let (_, rels) = compositeTp lhs rhs
  rels

let unifyTupArg (tup:FType*FType) =
  let (lhs, rhs) = tup
  unifyType lhs rhs


let collectStmtRel (ec:Expr->[]UniRel) (stmt:Stmt) : []UniRel =
  match stmt with
  | SExprStmt se -> ec se
  | SLetVarDef lvd ->
    let inside = ec lvd.rhs
    let one = unifyType lvd.lvar.ftype (ExprToType lvd.rhs)
    slice.Append one inside

/*
  collectXXX is subfunction for collectExprRel.

  collectXXX is called after inside of collection is done.
  So just check current layer for each node.
*/
let collectFunCall (fc: FunCall) =
  let tftype = fc.targetFunc.ftype
  match tftype with
  | FFunc fft ->
    slice.Map ExprToType fc.args
    |> slice.Zip (fargs fft) 
    |> slice.Map unifyTupArg
    |> slice.Concat
  | _ ->
    frt.Panic "funcall with non func first arg, possibly TypeVar, NYI."
    emptyRels ()

let collectSlice (es: []Expr) =
  if (slice.Length es) <= 1 then
    emptyRels ()
  else
    let headT = slice.Head es |> ExprToType
    slice.Tail es
    |> slice.Map ExprToType
    |> slice.Map (unifyType headT)
    |> slice.Concat

// This is exception for collectXXX.
// collect inside here.
let collectBlock (colE:Expr->[]UniRel) (colS:Stmt->[]UniRel) (block:Block) =
    slice.Map colS block.stmts
    |> slice.Concat
    |> slice.Append (colE block.finalExpr)

let mrToBlock (mr:MatchRule) =
  mr.body

let NEPToExpr (nep:NEPair) =
  nep.expr


let collectExprRel (expr:Expr) : []UniRel =
  let colB = collectBlock collectExprRel (collectStmtRel collectExprRel)
  match expr with
  | EFunCall fc ->
    let inside = slice.Map collectExprRel fc.args |> slice.Concat
    collectFunCall fc
    |> slice.Append inside
  | ESlice es ->
    let inside = slice.Map collectExprRel es |> slice.Concat
    collectSlice es
    |> slice.Append inside
  | ERecordGen rg ->
    // NYI: unify to recordType.  
    slice.Map NEPToExpr rg.fieldsNV
    |> slice.Map collectExprRel
    |> slice.Concat 
  | ELazyBlock lb ->
    colB lb.block
  | EReturnableExpr re ->
    match re with
    | RBlock bl ->
      colB bl
    | RMatchExpr me ->
      slice.Map mrToBlock me.rules
      |> slice.Map colB
      |> slice.Concat
      |> slice.Append (collectExprRel me.target)
  | _ -> emptyRels()

let lfdRetType (lfd:LetFuncDef) =
  match lfd.fvar.ftype with
  | FFunc ft -> freturn ft
  | _ ->
    frt.Panic "LetFuncDef's fvar is not FFunc type."
    FUnit

let collectLfdRels (lfd:LetFuncDef) =
  let brels = blockToExpr lfd.body
              |> collectExprRel
  let lastExprType = lfd.body.finalExpr |> ExprToType
  unifyType (lfdRetType lfd) lastExprType
  |> slice.Append brels

/*
  Building ResolveInfo from []UniRel

*/

package_info _ =
  type EquivSet
  type EquivInfoDict
  let eqsUnion: EquivSet->EquivSet->EquivSet
  let eqsItems: EquivSet->[]string
  let NewEquivSet: TypeVar->EquivSet
  let NewEquivInfoDict: ()->EquivInfoDict

/*
  resType is most concrete type for this equiv set.
  If only TypeVar is known, alphabetically first one is set.
*/
type EquivInfo = {eset: EquivSet; resType: FType}

// circular dependency.
package_info _ =
  let eidLookup: EquivInfoDict->string->EquivInfo*bool
  let eidPut: EquivInfoDict->string->EquivInfo->()


let eiUnion (e1: EquivInfo) (e2:EquivInfo) =
  let nset = eqsUnion e1.eset e2.eset
  let (nres, rels) = compositeTp e1.resType e2.resType
  let nei = {eset=nset; resType=nres}
  (nei, rels)

let eiUpdateResT (e: EquivInfo) (tcan:FType) =
  let (nres, rels) = compositeTp e.resType tcan
  let nei = {eset=e.eset; resType=nres}
  (nei, rels)

// EquivInfo which only contains TypeVar and resType is TypeVar.
let eiInit (tv:TypeVar) =
  let es = NewEquivSet tv
  let rtype = FTypeVar tv
  {eset=es; resType=rtype}

type Resolver = {eid: EquivInfoDict}

let newResolver () =
  let neid = NewEquivInfoDict ()
  {eid=neid}

let rsLookupEI (res:Resolver) (tvname:string) =
  let (ei, ok) = eidLookup res.eid tvname
  if ok then
    ei
  else
    // if not exist, return only tv's ei.
    eiInit {TypeVar.name=tvname}

let rsRegisterTo (res:Resolver) (ei:EquivInfo) (key:string) =
  eidPut res.eid key ei

let rsRegisterNewEI (res:Resolver) (ei:EquivInfo) =
  eqsItems ei.eset
  |> slice.Iter (rsRegisterTo res ei)

let updateResOne (res:Resolver) (rel:UniRel) =
  let ei1 = rsLookupEI res rel.srcV
  match rel.dest with
  | FTypeVar tvd ->
    let ei2 = rsLookupEI res tvd.name
    let (nei, rels) = eiUnion ei1 ei2
    rsRegisterNewEI res nei
    rels
  | _ ->
    let (nei, rels) = eiUpdateResT ei1 rel.dest
    if slice.IsEmpty rels then
      emptyRels ()
    else
      rsRegisterNewEI res nei
      rels

let updateResolver (res:Resolver) (rels:[]UniRel) : Resolver =
  let nrels = rels |> slice.Map (updateResOne res) |> slice.Concat
  if slice.IsEmpty nrels then
    res
  else
    updateResolver res nrels

let buildResolver (rels:[]UniRel) =
  let res = newResolver ()
  updateResolver res rels
  res

let rsResolveType (res:Resolver) (tvname:string) =
  let ei = rsLookupEI res tvname
  ei.resType

/*
  Resolve TypeVar
*/

/*
  TransformT FTypeVar and recomposite.
*/
let transTypeVarFType (transTV: TypeVar->FType) (ftp:FType) : FType =
  let recurse = transTypeVarFType transTV
  match ftp with
  | FTypeVar tv -> transTV tv
  | FSlice ts ->
    let et = recurse ts.elemType
    FSlice {SliceType.elemType = et}
  | FFunc fnt ->
    let nts = slice.Map recurse fnt.targets
    {FuncType.targets=nts}
    |> FFunc
  | _ -> ftp


let transOneTypeVar (rsv: Resolver) (tv:TypeVar) =
  rsResolveType rsv tv.name

let resolveType (rsv: Resolver) (ftp:FType) =
  transTypeVarFType (transOneTypeVar rsv) ftp

/*
  Self transform utility.
  Currently, assume transform Var to Var.
  Some are common to self transform Expr.
*/

let transExprNE (cnv:Expr->Expr) (p:NEPair) =
   {NEPair.name=p.name; expr=cnv p.expr}

let transVarStmt (transV:Var->Var) (transE:Expr->Expr) (stmt:Stmt) =
  match stmt with
  | SLetVarDef lvd ->
    let nvar = transV lvd.lvar
    let nrhs = transE lvd.rhs
    {lvar=nvar;rhs=nrhs} |> SLetVarDef
  | SExprStmt e -> 
    transE e |> SExprStmt

let transExprMatchRule (pExpr: Expr->Expr) (mr:MatchRule) =
  let nbody = blockToExpr mr.body |> pExpr |> exprToBlock
  {pattern=mr.pattern; body=nbody}

/*
  Self transform Var of expr.
  For composite expr, call each element and composite automatically.
*/
let transVarExpr (transV:Var->Var) (expr:Expr) : Expr =
  let transE = transVarExpr transV
  match expr with
  | EVar v -> transV v |> EVar
  | ESlice es -> slice.Map (transVarExpr transV) es |> ESlice
  | ERecordGen rg ->
    let newNV = slice.Map (transExprNE transE) rg.fieldsNV
    {fieldsNV=newNV; recordType=rg.recordType}
    |> ERecordGen
  | EReturnableExpr re -> 
    match re with
    | RBlock bl ->
      let nss = bl.stmts |> slice.Map (transVarStmt transV transE)
      let fexpr = transE bl.finalExpr
      {Block.stmts=nss; finalExpr=fexpr}
      |> blockToExpr
    | RMatchExpr me ->
      let ntarget = transE me.target
      let nrules = slice.Map (transExprMatchRule transE) me.rules
      {target=ntarget; rules=nrules}
      |> RMatchExpr
      |> EReturnableExpr
  | EFunCall fc ->
    let ntarget = transV fc.targetFunc
    let nargs = slice.Map transE fc.args
    {targetFunc=ntarget;args=nargs}
    |> EFunCall
  | EBoolLiteral _ -> expr
  | EGoEvalExpr _ -> expr
  | EStringLiteral _ -> expr
  | EIntImm _ -> expr
  | EUnit -> expr
  | EFieldAccess _ -> expr

/*
  resolve type using transVarExpr utility.
*/

let resolveVarType (rsv: Resolver) (v:Var) =
  {Var.name=v.name; ftype=resolveType rsv v.ftype}

let resolveExprType (rsv: Resolver) (expr:Expr) : Expr =
  transVarExpr (resolveVarType rsv) expr

let resolveBlockType (rsv: Resolver) (bl:Block) : Block =
  blockToExpr bl
  |> resolveExprType rsv
  |> exprToBlock

/*
and LetFuncDef = {fvar: Var; params: []Var; body:Block}
and RootFuncDef = {tparams:[]string; lfd:LetFuncDef}
*/

let resolveLfd (rsv: Resolver) (lfd:LetFuncDef) =
   let nfvar = resolveVarType rsv lfd.fvar
   let nparams = slice.Map (resolveVarType rsv) lfd.params
   let nbody = resolveBlockType rsv lfd.body
   {fvar=nfvar; params=nparams; body=nbody}

let notFound (rsv:Resolver) (key:string) =
  let rtype = rsResolveType rsv key
  match rtype with
  | FTypeVar tv ->
    // resType is the same TypeVar, means not found.
    tv.name = key
  | _ -> false

/*
  Infer TypeVar's and promote as TypeParameters if necessary, then return RootFuncDef.
*/
let Infer (tvnames:[]string) (lfd:LetFuncDef) =
  let rels = collectLfdRels lfd
  // frt.Printf1 "%v\n" rels
  let rsv = buildResolver rels
  // let unresTvs = slice.Filter (notFound rsv) tvnames
  // frt.Printf1 "unres: %v\n" unresTvs
  // assign formal type parameter
  // NYI.
  let tps = GoEval<[]string> "[]string{}"
  let nlfd = resolveLfd rsv lfd
  {tparams=tps; lfd=nlfd}