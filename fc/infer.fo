package main

import frt
import slice

/*
  UniRel collection.
*/

// src VarType and dest FType has unique constraints.
// If both are VarType, src is alphabetically later order (to avoid cyclic reference to later stage).
type UniRel = {SrcV:string; Dest: FType}

let emptyRels () =
  GoEval<[]UniRel> "[]UniRel{}"

// generics it NYI...
let tupApply (f:FType->FType->FType*[]UniRel) (tup:FType*FType) =
  let (lhs, rhs) = tup
  f lhs rhs

let withRels (rels:[]UniRel) (tp:FType) =
  (tp, rels)

let withTp (tp:FType) (rels:[]UniRel) =
  (tp, rels)


let compositeTpList (cOne: FType->FType->FType*[]UniRel) (lhs: []FType) (rhs: []FType) =
  let tups = slice.Zip lhs rhs
              |> slice.Map (tupApply cOne)
  let tps = tups |> slice.Map frt.Fst 
  let rels = tups |> slice.Map frt.Snd |> slice.Concat
  (tps, rels)


/*
  compare two type and adopt concrete one.
  
  tp1: int->T1->[]string
  tp2: int->int->[]T2

  result type is: int->int->[]string
  unirel is: [{T1->int}; {T2->string}]

  If you just need unirel, just discard result type. 
*/
let compositeTp (lhs:FType) (rhs:FType) : FType*[]UniRel =
  match lhs with
  | FTypeVar tv ->
    match rhs with
    | FTypeVar tv2 ->
      // same typevar
      if tv.Name = tv2.Name then        
        emptyRels ()
        |> withTp lhs
      elif tv.Name > tv2.Name then
        // keep alphabetically later one to src.
        [{SrcV=tv.Name; Dest=rhs}]
        |> withTp rhs
      else
        [{SrcV=tv2.Name;Dest=lhs}]
        |> withTp lhs
    | _ ->
      [{SrcV=tv.Name; Dest=rhs}]
      |> withTp rhs
  | _ ->
    match rhs with
    | FTypeVar tv2 ->
      [{SrcV=tv2.Name; Dest=lhs}]
      |> withTp lhs
    // Both are not FTypeVar, drill down.
    // Both type must be equal for this layer.
    | FSlice ts2 ->
      match lhs with
      | FSlice ts1 ->
        let (rtp, rels) = compositeTp ts1.ElemType ts2.ElemType
        {SliceType.ElemType=rtp}
        |> FSlice
        |> withRels rels
      | FFieldAccess _ ->
        // []T1 = FA(T2, "xx") case.
        // It is difficult to handle.
        // So just give up for this case.
        // Hope other relation will resolve all type.
        emptyRels ()
        |> withTp rhs // slice would be better.
      | _ ->
        frt.Panic "right is slice, left is neither slice nor field access."
        emptyRels ()
        |> withTp lhs
    | FFieldAccess fa2 ->
      match lhs with
      | FFieldAccess fa1 ->
        let (rtp, rels) = compositeTp fa1.RecType fa2.RecType
        {RecType=rtp; FieldName=fa1.FieldName}
        |>faResolve
        |> withRels rels
      | FSlice _ ->
        // []T1 = FA(T2, "xx") case.
        // same as above 
        emptyRels ()
        |> withTp lhs
      | _ ->
        frt.Panic "unknown case"
        emptyRels ()
        |> withTp lhs
    | FFunc tf2 ->
      let tf1 = GoEval<FuncType> "lhs.(FType_FFunc).Value"
      let (tps, rels) = compositeTpList compositeTp tf1.Targets tf2.Targets
      {FuncType.Targets=tps}
      |> FFunc
      |> withRels rels
    | FTuple tt2 ->
      let tt1 = GoEval<TupleType> "lhs.(FType_FTuple).Value"
      // [](type*[]UniRel)
      let (tps, rels) = compositeTpList compositeTp tt1.ElemTypes tt2.ElemTypes
      {TupleType.ElemTypes=tps}
      |> FTuple
      |> withRels rels
    | _ ->
      // both type is concrete.
      emptyRels ()
      |> withTp lhs


let unifyType (lhs:FType) (rhs:FType) : []UniRel =
  let (_, rels) = compositeTp lhs rhs
  rels

let unifyTupArg (tup:FType*FType) =
  let (lhs, rhs) = tup
  unifyType lhs rhs

// Var's type-Expr unify, but ignore "_"
let unifyVETup (veTup: Var*FType) =
  let (v, ft) = veTup
  if v.Name = "_" then
    emptyRels ()
  else
    unifyType v.Ftype ft

let vToT (v:Var) =
  v.Ftype

let varsToTupleType (vars: []Var) =
  let ets = slice.Map vToT vars
  {ElemTypes=ets}
  |> FTuple

let collectStmtRel (ec:Expr->[]UniRel) (stmt:Stmt) : []UniRel =
  match stmt with
  | SExprStmt se -> ec se
  | SLetVarDef slvd ->
    match slvd with
    | LLOneVarDef lvd ->
      let inside = ec lvd.Rhs
      unifyType lvd.Lvar.Ftype (ExprToType lvd.Rhs)
      |> slice.Append inside
    | LLDestVarDef ldvd ->
        let inside = ec ldvd.Rhs
        let rhtype = ExprToType ldvd.Rhs
        match rhtype with
        | FTuple ft ->
          slice.Zip ldvd.Lvars ft.ElemTypes
          |> slice.Map unifyVETup
          |> slice.Concat
          |> slice.Append inside
        | FTypeVar _ ->
          let lft = varsToTupleType ldvd.Lvars
          unifyType rhtype lft
          |> slice.Append inside
        | _ ->
          frt.Panic "Destructuring of right is not tuple, NYI."
          inside

/*
  collectXXX is subfunction for collectExprRel.

  collectXXX is called after inside of collection is done.
  So just check current layer for each node.
*/
let collectFunCall (fc: FunCall) =
  let tftype = varRefVarType fc.TargetFunc
  match tftype with
  | FFunc fft ->
    let argTps = slice.Map ExprToType fc.Args
    let tpArgTps = (fargs fft) |> slice.Take (slice.Length argTps)
    slice.Zip argTps tpArgTps
    |> slice.Map unifyTupArg
    |> slice.Concat
  | _ ->
    frt.Panic "funcall with non func first arg, possibly TypeVar, NYI."
    emptyRels ()

let collectSlice (es: []Expr) =
  if (slice.Length es) <= 1 then
    emptyRels ()
  else
    let headT = slice.Head es |> ExprToType
    slice.Tail es
    |> slice.Map ExprToType
    |> slice.Map (unifyType headT)
    |> slice.Concat

// This is exception for collectXXX.
// collect inside here.
let collectBlock (colE:Expr->[]UniRel) (colS:Stmt->[]UniRel) (block:Block) =
    slice.Map colS block.Stmts
    |> slice.Concat
    |> slice.Append (colE block.FinalExpr)

let mrToBlock (mr:MatchRule) =
  mr.Body

let NEPToExpr (nep:NEPair) =
  nep.Expr


let collectExprRel (expr:Expr) : []UniRel =
  let colB = collectBlock collectExprRel (collectStmtRel collectExprRel)
  match expr with
  | EFunCall fc ->
    let inside = slice.Map collectExprRel fc.Args |> slice.Concat
    collectFunCall fc
    |> slice.Append inside
  | EBinOpCall bop ->
    let insideL = collectExprRel bop.Lhs 
    let insideR = collectExprRel bop.Rhs
    let lft = ExprToType bop.Lhs
    let rft = ExprToType bop.Rhs
    let teq = unifyType lft rft
    let all = [insideL;insideR;teq]
    slice.Concat all
  | ESlice es ->
    let inside = slice.Map collectExprRel es |> slice.Concat
    collectSlice es
    |> slice.Append inside
  | ERecordGen rg ->
    // NYI: unify to recordType.  
    slice.Map NEPToExpr rg.FieldsNV
    |> slice.Map collectExprRel
    |> slice.Concat 
  | ELazyBlock lb ->
    colB lb.Block
  | EReturnableExpr re ->
    match re with
    | RBlock bl ->
      colB bl
    | RMatchExpr me ->
      slice.Map mrToBlock me.Rules
      |> slice.Map colB
      |> slice.Concat
      |> slice.Append (collectExprRel me.Target)
  | _ -> emptyRels()

let lfdRetType (lfd:LetFuncDef) =
  match lfd.Fvar.Ftype with
  | FFunc ft -> freturn ft
  | _ ->
    frt.Panic "LetFuncDef's fvar is not FFunc type."
    FUnit

let collectLfdRels (lfd:LetFuncDef) =
  let brels = blockToExpr lfd.Body
              |> collectExprRel
  let lastExprType = lfd.Body.FinalExpr |> ExprToType
  unifyType (lfdRetType lfd) lastExprType
  |> slice.Append brels

/*
  Building ResolveInfo from []UniRel

*/

package_info _ =
  type EquivSet
  let eqsUnion: EquivSet->EquivSet->EquivSet
  let eqsItems: EquivSet->[]string
  let NewEquivSet: TypeVar->EquivSet

/*
  resType is most concrete type for this equiv set.
  If only TypeVar is known, alphabetically first one is set.
*/
type EquivInfo = {eset: EquivSet; resType: FType}

// circular dependency.
package_info _ =
  let eidLookup: EquivInfoDict->string->EquivInfo*bool
  let eidPut: EquivInfoDict->string->EquivInfo->()


let eiUnion (e1: EquivInfo) (e2:EquivInfo) =
  let nset = eqsUnion e1.eset e2.eset
  let (nres, rels) = compositeTp e1.resType e2.resType
  let nei = {eset=nset; resType=nres}
  (nei, rels)

let eiUpdateResT (e: EquivInfo) (tcan:FType) =
  let (nres, rels) = compositeTp e.resType tcan
  let nei = {eset=e.eset; resType=nres}
  (nei, rels)

// EquivInfo which only contains TypeVar and resType is TypeVar.
let eiInit (tv:TypeVar) =
  let es = NewEquivSet tv
  let rtype = FTypeVar tv
  {eset=es; resType=rtype}


let rsLookupEI (res:Resolver) (tvname:string) =
  let (ei, ok) = eidLookup res.eid tvname
  if ok then
    ei
  else
    // if not exist, return only tv's ei.
    eiInit {TypeVar.Name=tvname}

let rsRegisterTo (res:Resolver) (ei:EquivInfo) (key:string) =
  eidPut res.eid key ei

let rsRegisterNewEI (res:Resolver) (ei:EquivInfo) =
  eqsItems ei.eset
  |> slice.Iter (rsRegisterTo res ei)

let updateResOne (res:Resolver) (rel:UniRel) =
  let ei1 = rsLookupEI res rel.SrcV
  match rel.Dest with
  | FTypeVar tvd ->
    let ei2 = rsLookupEI res tvd.Name
    let (nei, rels) = eiUnion ei1 ei2
    rsRegisterNewEI res nei
    rels
  | _ ->
    let (nei, rels) = eiUpdateResT ei1 rel.Dest
    if slice.IsEmpty rels then
      emptyRels ()
    else
      rsRegisterNewEI res nei
      rels

let updateResolver (res:Resolver) (rels:[]UniRel) : Resolver =
  let nrels = rels |> slice.Map (updateResOne res) |> slice.Concat
  if slice.IsEmpty nrels then
    res
  else
    updateResolver res nrels

let rsResolveType (resT:FType->FType) (res:Resolver) (tvname:string) =
  let ei = rsLookupEI res tvname
  let rcand = ei.resType
  match rcand with
  | FTypeVar tv ->
    if tv.Name = tvname then
      // same type var, no need to drill down.
      rcand
    else
      resT rcand
  | _ -> resT rcand


/*
  Self transform utility.
  Currently, assume transform Var to Var.
  Some are common to self transform Expr.
*/

let transExprNE (cnv:Expr->Expr) (p:NEPair) =
   {NEPair.Name=p.Name; Expr=cnv p.Expr}

let transVarStmt (transV:Var->Var) (transE:Expr->Expr) (stmt:Stmt) =
  match stmt with
  | SLetVarDef llvd ->
    match llvd with
    | LLOneVarDef lvd ->
      let nvar = transV lvd.Lvar
      let nrhs = transE lvd.Rhs
      {Lvar=nvar; Rhs=nrhs} |> LLOneVarDef |> SLetVarDef
    | LLDestVarDef ldvd ->
      let nvars = slice.Map transV ldvd.Lvars
      let nrhs = transE ldvd.Rhs
      {Lvars=nvars;Rhs=nrhs} |> LLDestVarDef |> SLetVarDef
  | SExprStmt e -> 
    transE e |> SExprStmt

let transExprMatchRule (pExpr: Expr->Expr) (mr:MatchRule) =
  let nbody = blockToExpr mr.Body |> pExpr |> exprToBlock
  {Pattern=mr.Pattern; Body=nbody}

let transVarBlock (transE:Expr->Expr) (transS:Stmt->Stmt) (bl:Block) =
  let nss = bl.Stmts |> slice.Map transS
  let fexpr = transE bl.FinalExpr
  {Block.Stmts=nss; FinalExpr=fexpr}

/*
  Self transform Var of expr.
  For composite expr, call each element and composite automatically.
*/
let transVarExpr (transV:Var->Var) (expr:Expr) : Expr =
  let transE = transVarExpr transV
  let transS = (transVarStmt transV transE)
  match expr with
  | EVarRef rv ->
    match rv with
    | VRVar v ->
       transV v |> VRVar |> EVarRef
    | VRSVar sv ->
       let nv = transV sv.Var
       {SpecVar.Var=nv; SpecList=sv.SpecList}
       |> VRSVar |> EVarRef
  | ESlice es -> slice.Map transE es |> ESlice
  | EBinOpCall bop ->
     let nlhs = transE bop.Lhs
     let nrhs = transE bop.Rhs
     {Op=bop.Op; Rtype=bop.Rtype; Lhs=nlhs; Rhs=nrhs}
     |> EBinOpCall
  | ETupleExpr es -> slice.Map (transVarExpr transV) es |> ETupleExpr
  | ERecordGen rg ->
    let newNV = slice.Map (transExprNE transE) rg.FieldsNV
    {FieldsNV=newNV; RecordType=rg.RecordType}
    |> ERecordGen
  | ELazyBlock lb ->
    let nbl = transVarBlock transE transS lb.Block
    {LazyBlock.Block=nbl}
    |> ELazyBlock
  | EReturnableExpr re -> 
    match re with
    | RBlock bl ->
      transVarBlock transE transS bl
      |> blockToExpr
    | RMatchExpr me ->
      let ntarget = transE me.Target
      let nrules = slice.Map (transExprMatchRule transE) me.Rules
      {Target=ntarget; Rules=nrules}
      |> RMatchExpr
      |> EReturnableExpr
  | EFunCall fc ->
    let ntarget =  transVarVR transV fc.TargetFunc
    let nargs = slice.Map transE fc.Args
    {TargetFunc=ntarget;Args=nargs}
    |> EFunCall
  | EBoolLiteral _ -> expr
  | EGoEvalExpr _ -> expr
  | EStringLiteral _ -> expr
  | EIntImm _ -> expr
  | EUnit -> expr
  | EFieldAccess fa ->
    let ntarget = transE fa.TargetExpr
    {TargetExpr=ntarget; FieldName=fa.FieldName}
    |> EFieldAccess

let transVarBlockFacade (transV:Var->Var) (block:Block) =
  let transE = transVarExpr transV
  let transS = (transVarStmt transV transE)
  transVarBlock transE transS block

let transVarLfd (transV:Var->Var) (lfd:LetFuncDef) =
   let nfvar = transV lfd.Fvar
   let nparams = slice.Map transV lfd.Params
   let nbody = transVarBlockFacade transV lfd.Body
   {Fvar=nfvar; Params=nparams; Body=nbody}


/*
type var collection.

This is used later, but implementation is similar to above transVarExpr.
So I place here.
Both are catamorphism but currently folang generics is not enough to create it.

Create collectXXXStmt, collectXXXBlock, collectXXXExpr.
*/

let collectTVarStmt (collE:Expr->[]string) (stmt:Stmt) =
  match stmt with
  | SLetVarDef llvd ->
    match llvd with
    | LLOneVarDef lvd ->
      let nvar = collectTVarFType lvd.Lvar.Ftype
      let nrhs = collE lvd.Rhs
      slice.Append nvar nrhs
    | LLDestVarDef ldvd ->
      let nvars = slice.Map vToT ldvd.Lvars |> slice.Collect collectTVarFType
      let nrhs = collE ldvd.Rhs
      slice.Append nvars nrhs
  | SExprStmt e -> 
    collE e

let collectTVarBlock (collE:Expr->[]string) (collS:Stmt->[]string) (bl:Block) =
  let nss = bl.Stmts |> slice.Collect collS
  let fexpr = collE bl.FinalExpr
  slice.Append nss fexpr

let collectTVarExpr (expr:Expr) : []string =
  let recurse = collectTVarExpr
  let collS = collectTVarStmt recurse
  let collB = collectTVarBlock recurse collS
  match expr with
  | EVarRef vr ->
     varRefVarType vr |> collectTVarFType
  | ESlice es -> slice.Collect recurse es
  | EBinOpCall bop ->
     let lres = recurse bop.Lhs
     let rres = recurse bop.Rhs
     slice.Append lres rres
  | ETupleExpr es -> slice.Collect recurse es
  | ERecordGen rg ->
    slice.Map NEPToExpr rg.FieldsNV
    |> slice.Collect recurse
  | ELazyBlock lb ->
    collB lb.Block
  | EReturnableExpr re -> 
    match re with
    | RBlock bl ->
      collB bl
    | RMatchExpr me ->
      slice.Map mrToBlock me.Rules |> slice.Collect collB
      |> slice.Append (recurse me.Target)
  | EFunCall fc ->
    let colt = varRefVarType fc.TargetFunc |> collectTVarFType 
    slice.Collect recurse fc.Args
    |> slice.Append colt
  | EFieldAccess fa ->
    recurse fa.TargetExpr
  | _ -> GoEval<[]string> "[]string{}"

let collectTVarBlockFacade (b:Block) =
  let collE = collectTVarExpr
  let collS = collectTVarStmt collE
  collectTVarBlock collE collS b

/*
  resolve type using transVarExpr utility.
*/

let resolveOneTypeVar (resT:FType->FType) (rsv: Resolver) (tv:TypeVar) =
  rsResolveType resT rsv tv.Name

let resolveType (rsv: Resolver) (ftp:FType) : FType =
  let resT = resolveType rsv
  transTypeVarFType (resolveOneTypeVar resT rsv) ftp


let resolveVarType (rsv: Resolver) (v:Var) =
  {Var.Name=v.Name; Ftype=resolveType rsv v.Ftype}

let resolveExprType (rsv: Resolver) (expr:Expr) : Expr =
  transVarExpr (resolveVarType rsv) expr

let resolveLfd (rsv: Resolver) (lfd:LetFuncDef) =
  transVarLfd (resolveVarType rsv) lfd

let notFound (rsv:Resolver) (key:string) =
  let resT = resolveType rsv
  let rtype = rsResolveType resT rsv key
  match rtype with
  | FTypeVar tv ->
    // resType is the same TypeVar, means not found.
    tv.Name = key
  | _ -> false


let InferExpr (tvc:TypeVarCtx) (expr:Expr) =
   let rels = collectExprRel expr
   updateResolver tvc.resolver rels
   resolveExprType tvc.resolver expr

let collectTVarLfd (lfd:LetFuncDef) =
  let vres = collectTVarFType lfd.Fvar.Ftype
  let pres = slice.Map vToT lfd.Params |> slice.Collect collectTVarFType
  let bres = collectTVarBlockFacade lfd.Body
  let res = [vres;pres;bres] // poor parse.
  slice.Concat res

let newTName (i:int) (n:string) =
  frt.Sprintf1 "T%d" i

let replaceSDict (ttdict:SDict) (tv:TypeVar) =
  let (nname, _) = sdLookup ttdict tv.Name
  {TypeVar.Name=nname} |> FTypeVar


let hoistTVar (unresT:[]string) (lfd:LetFuncDef) =
  let newTs = slice.Mapi newTName unresT
  let ttdict = slice.Zip unresT newTs |> toSDict
  let transV = transOneVar (replaceSDict ttdict)
  let nlfd = transVarLfd transV lfd
  (newTs, nlfd)


/*
  Infer TypeVar's and promote as TypeParameters if necessary, then return RootFuncDef.
*/
let InferLfd (tvc:TypeVarCtx) (lfd:LetFuncDef) =
  let rels = collectLfdRels lfd
  // frt.Printf1 "%v\n" rels
  updateResolver tvc.resolver rels
  let nlfd = resolveLfd tvc.resolver lfd
  let unresTvs = collectTVarLfd nlfd |> slice.Distinct
  // frt.Printf1 "unres: %v\n" unresTvs
  let (newTvs, nlfd2) = hoistTVar unresTvs nlfd
  // frt.Printf1 "newTvs: %v\n" newTvs
  {Tparams=newTvs; Lfd=nlfd2}