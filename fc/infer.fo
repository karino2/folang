package main

import frt
import slice

package_info _ =
  type TypeDict
  let toTDict: []string*FType->TypeDict
  let tdLookup: TypeDict->string->FType*bool
  let tdPut: TypeDict->string->FType->()
  let tdLookupNF: TypeDict->string->FType


// src VarType and dest FType has unique constraints.
// If both are VarType, src is alphabetically later order (to avoid cyclic reference to later stage).
type UniRel = {srcV:string; dest: FType}

let emptyRels () =
  GoEval<[]UniRel> "[]UniRel{}"

let relToTp (rel:UniRel) =
  (rel.srcV, rel.dest)

let relsToTDict (rels: []UniRel) =
  slice.Map relToTp rels
  |> toTDict

let tupApply (f:FType->FType->[]UniRel) (tup:FType*FType) =
  let (lhs, rhs) = tup
  f lhs rhs

let unifyType (lhs:FType) (rhs:FType) : []UniRel =
  match lhs with
  | FTypeVar tv ->
    match rhs with
    | FTypeVar tv2 ->
      // same typevar
      if tv.name = tv2.name then
        emptyRels ()
      elif tv.name > tv2.name then
        // keep alphabetically later one to src.
        [{srcV=tv.name; dest=rhs}]
      else
        [{srcV=tv2.name;dest=lhs}]
    | _ ->
      [{srcV=tv.name; dest=rhs}]
  | _ ->
    match rhs with
    | FTypeVar tv2 ->
      [{srcV=tv2.name; dest=lhs}]
    // Both are not FTypeVar, drill down.
    // Both type must be equal for this layer.
    | FSlice ts2 ->
      let ts1 = GoEval<SliceType> "lhs.(FType_FSlice).Value"
      unifyType ts1.elemType ts2.elemType
    | FFunc tf2 ->
      let tf1 = GoEval<FuncType> "lhs.(FType_FFunc).Value"
      slice.Zip tf1.targets tf2.targets
      |> slice.Map (tupApply unifyType)
      |> slice.Concat 
    | _ -> emptyRels () // both type is concrete.

let unifyTupArg (tup:FType*FType) =
  let (lhs, rhs) = tup
  unifyType lhs rhs


let collectStmtRel (ec:Expr->[]UniRel) (stmt:Stmt) : []UniRel =
  match stmt with
  | SExprStmt se -> ec se
  | SLetVarDef lvd ->
    let inside = ec lvd.rhs
    let one = unifyType lvd.lvar.ftype (ExprToType lvd.rhs)
    slice.Append one inside

/*
  collectXXX is subfunction for collectExprRel.

  collectXXX is called after inside of collection is done.
  So just check current layer for each node.
*/
let collectFunCall (fc: FunCall) =
  let tftype = fc.targetFunc.ftype
  match tftype with
  | FFunc fft ->
    slice.Map ExprToType fc.args
    |> slice.Zip (fargs fft) 
    |> slice.Map unifyTupArg
    |> slice.Concat
  | _ ->
    frt.Panic "funcall with non func first arg, possibly TypeVar, NYI."
    emptyRels ()

let collectSlice (es: []Expr) =
  if (slice.Length es) <= 1 then
    emptyRels ()
  else
    let headT = slice.Head es |> ExprToType
    slice.Tail es
    |> slice.Map ExprToType
    |> slice.Map (unifyType headT)
    |> slice.Concat

// This is exception for collectXXX.
// collect inside here.
let collectBlock (colE:Expr->[]UniRel) (colS:Stmt->[]UniRel) (block:Block) =
    slice.Map colS block.stmts
    |> slice.Concat
    |> slice.Append (colE block.finalExpr)

let mrToBlock (mr:MatchRule) =
  mr.body

let NEPToExpr (nep:NEPair) =
  nep.expr


let collectExprRel (expr:Expr) : []UniRel =
  let colB = collectBlock collectExprRel (collectStmtRel collectExprRel)
  match expr with
  | EFunCall fc ->
    let inside = slice.Map collectExprRel fc.args |> slice.Concat
    collectFunCall fc
    |> slice.Append inside
  | ESlice es ->
    let inside = slice.Map collectExprRel es |> slice.Concat
    collectSlice es
    |> slice.Append inside
  | ERecordGen rg ->
    // NYI: unify to recordType.  
    slice.Map NEPToExpr rg.fieldsNV
    |> slice.Map collectExprRel
    |> slice.Concat 
  | ELazyBlock lb ->
    colB lb.block
  | EReturnableExpr re ->
    match re with
    | RBlock bl ->
      colB bl
    | RMatchExpr me ->
      slice.Map mrToBlock me.rules
      |> slice.Map colB
      |> slice.Concat
      |> slice.Append (collectExprRel me.target)
  | _ -> emptyRels()

let lfdRetType (lfd:LetFuncDef) =
  match lfd.fvar.ftype with
  | FFunc ft -> freturn ft
  | _ ->
    frt.Panic "LetFuncDef's fvar is not FFunc type."
    FUnit

let collectLfdRels (lfd:LetFuncDef) =
  let brels = blockToExpr lfd.body
              |> collectExprRel
  let lastExprType = lfd.body.finalExpr |> ExprToType
  unifyType (lfdRetType lfd) lastExprType
  |> slice.Append brels

/*
  TransformT FTypeVar and recomposite.
*/
let transTypeVarFType (transTV: TypeVar->FType) (ftp:FType) : FType =
  let recurse = transTypeVarFType transTV
  match ftp with
  | FTypeVar tv -> transTV tv
  | FSlice ts ->
    let et = recurse ts.elemType
    FSlice {SliceType.elemType = et}
  | FFunc fnt ->
    let nts = slice.Map recurse fnt.targets
    {FuncType.targets=nts}
    |> FFunc
  | _ -> ftp


let transOneTypeVar (tdict: TypeDict) (tv:TypeVar) =
  tdLookupNF tdict tv.name

let resolveType (tdict: TypeDict) (ftp:FType) =
  transTypeVarFType (transOneTypeVar tdict) ftp

/*
  Self transform utility.
  Currently, assume transform Var to Var.
  Some are common to self transform Expr.
*/

let transExprNE (cnv:Expr->Expr) (p:NEPair) =
   {NEPair.name=p.name; expr=cnv p.expr}

let transVarStmt (transV:Var->Var) (transE:Expr->Expr) (stmt:Stmt) =
  match stmt with
  | SLetVarDef lvd ->
    let nvar = transV lvd.lvar
    let nrhs = transE lvd.rhs
    {lvar=nvar;rhs=nrhs} |> SLetVarDef
  | SExprStmt e -> 
    transE e |> SExprStmt

let transExprMatchRule (pExpr: Expr->Expr) (mr:MatchRule) =
  let nbody = blockToExpr mr.body |> pExpr |> exprToBlock
  {pattern=mr.pattern; body=nbody}

/*
  Self transform Var of expr.
  For composite expr, call each element and composite automatically.
*/
let transVarExpr (transV:Var->Var) (expr:Expr) : Expr =
  let transE = transVarExpr transV
  match expr with
  | EVar v -> transV v |> EVar
  | ESlice es -> slice.Map (transVarExpr transV) es |> ESlice
  | ERecordGen rg ->
    let newNV = slice.Map (transExprNE transE) rg.fieldsNV
    {fieldsNV=newNV; recordType=rg.recordType}
    |> ERecordGen
  | EReturnableExpr re -> 
    match re with
    | RBlock bl ->
      let nss = bl.stmts |> slice.Map (transVarStmt transV transE)
      let fexpr = transE bl.finalExpr
      {Block.stmts=nss; finalExpr=fexpr}
      |> blockToExpr
    | RMatchExpr me ->
      let ntarget = transE me.target
      let nrules = slice.Map (transExprMatchRule transE) me.rules
      {target=ntarget; rules=nrules}
      |> RMatchExpr
      |> EReturnableExpr
  | EFunCall fc ->
    let ntarget = transV fc.targetFunc
    let nargs = slice.Map transE fc.args
    {targetFunc=ntarget;args=nargs}
    |> EFunCall
  | EBoolLiteral _ -> expr
  | EGoEvalExpr _ -> expr
  | EStringLiteral _ -> expr
  | EIntImm _ -> expr
  | EUnit -> expr
  | EFieldAccess _ -> expr

/*
  resolve type using transVarExpr utility.
*/

let resolveVarType (tdict: TypeDict) (v:Var) =
  {Var.name=v.name; ftype=resolveType tdict v.ftype}

let resolveExprType (tdict: TypeDict) (expr:Expr) : Expr =
  transVarExpr (resolveVarType tdict) expr

let resolveBlockType (tdict: TypeDict) (bl:Block) : Block =
  blockToExpr bl
  |> resolveExprType tdict
  |> exprToBlock

/*
and LetFuncDef = {fvar: Var; params: []Var; body:Block}
and RootFuncDef = {tparams:[]string; lfd:LetFuncDef}
*/

let resolveLfd (tdict: TypeDict) (lfd:LetFuncDef) =
   let nfvar = resolveVarType tdict lfd.fvar
   let nparams = slice.Map (resolveVarType tdict) lfd.params
   let nbody = resolveBlockType tdict lfd.body
   {fvar=nfvar; params=nparams; body=nbody}

let notFound (dic:TypeDict) (key:string) =
  let (_, ok) = tdLookup dic key
  not ok

/*
  Infer TypeVar's and promote as TypeParameters if necessary, then return RootFuncDef.
*/
let Infer (tvnames:[]string) (lfd:LetFuncDef) =
  let rels = collectLfdRels lfd
  // frt.Printf1 "%v\n" rels
  // this is not enough.
  // merge and select most concrete type.
  let rdict = relsToTDict rels
  // let unresTvs = slice.Filter (notFound rdict) tvnames
  // frt.Printf1 "unres: %v\n" unresTvs
  // assign formal type parameter
  // NYI.
  let tps = GoEval<[]string> "[]string{}"
  let nlfd = resolveLfd rdict lfd
  {tparams=tps; lfd=nlfd}