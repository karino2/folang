package main

import frt
import buf
import slice
import strings

type FType =
| FInt
| FString
| FBool
| FUnit
| FUnresolved
| FFunc of FuncType
| FRecord of RecordType
| FUnion of UnionType
| FExtType of string
| FSlice of SliceType
and SliceType = {elemType: FType}
and FuncType = {targets: []FType}
and NameTypePair = {name: string; ftype: FType}
and RecordType = {name: string; fiedls: []NameTypePair}
and UnionType = {name: string; cases: []NameTypePair}

let IsUnresolved (ft:FType) =
  match ft with
  | FUnresolved -> true
  | _ -> false

let fargs (ft:FuncType) =
  let l = slice.Length ft.targets
  ft.targets |> slice.Take (l-1)

let FFuncToGo (ft:FuncType) (toGo:FType->string) =
  let last = slice.Last ft.targets
  let args = fargs ft
  let bw = buf.New ()
  buf.Write bw "func ("
  args |> slice.Map toGo |> strings.Concat "," |> buf.Write bw
  buf.Write bw ")"
  let ret = match last with
            | FUnit -> ""
            | _ -> " " + (toGo last)
  buf.Write bw ret
  buf.String bw

let FRecordToGo (frec: RecordType) =
  frec.name

let FUnionToGo (fu: UnionType) =
  fu.name

let FSliceToGo (fs: SliceType) (toGo:FType->string) =
  "[]" + (toGo fs.elemType)

let FTypeToGo (ft:FType) : string =
  match ft with
  | FInt -> "int"
  | FBool -> "bool"
  | FString -> "string"    
  | FUnit -> "" // When use as return type in Go, "" is suitable.
  | FUnresolved -> "" // This case is error. Just return "" for a while.
  | FFunc ft -> FFuncToGo ft FTypeToGo
  | FRecord fr -> FRecordToGo fr
  | FUnion fu -> FUnionToGo fu
  | FExtType fe -> fe // for external type with typename fe, use that type name as is.
  | FSlice fs -> FSliceToGo fs FTypeToGo

