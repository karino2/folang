package main

import frt
import buf
import slice
import strings

/*
  Type variable, used for type inference and type parameter.
*/
type TypeVar = {name: string}

type FType =
| FInt
| FString
| FBool
| FUnit
| FFunc of FuncType
| FRecord of RecordType
| FUnion of UnionType
| FExtType of string
| FSlice of SliceType
| FPreUsed of string
| FTypeVar of TypeVar
and SliceType = {elemType: FType}
and FuncType = {targets: []FType}
and NameTypePair = {name: string; ftype: FType}
and RecordType = {name: string; fields: []NameTypePair}
and UnionType = {name: string; cases: []NameTypePair}

let fargs (ft:FuncType) =
  let l = slice.Length ft.targets
  ft.targets |> slice.Take (l-1)

let freturn (ft:FuncType) =
  slice.Last ft.targets

let funcTypeToGo (ft:FuncType) (toGo:FType->string) =
  let last = slice.Last ft.targets
  let args = fargs ft
  let bw = buf.New ()
  buf.Write bw "func ("
  args |> slice.Map toGo |> strings.Concat "," |> buf.Write bw
  buf.Write bw ")"
  let ret = match last with
            | FUnit -> ""
            | _ -> " " + (toGo last)
  buf.Write bw ret
  buf.String bw

let recordTypeToGo (frec: RecordType) =
  frec.name

let frStructName (frec: RecordType) =
  frec.name

let namePairMatch (targetName :string) (pair: NameTypePair) =
  targetName = pair.name

let lookupPairByName (targetName:string) (pairs: []NameTypePair) =
  // let res = pairs |> slice.Filter (fun x-> x.Name == fieldName)
  let res = pairs |> slice.Filter (namePairMatch targetName)
  slice.Head res

let frGetField (frec: RecordType) (fieldName: string) =
  lookupPairByName fieldName frec.fields

let npName (pair:NameTypePair) =
  pair.name

let frMatch (frec: RecordType) (fieldNames: []string)=
  if (slice.Length fieldNames) <> (slice.Length frec.fields) then
    false
  else
    // let sortedInput = slice.Sort fieldNames
    let sortedInput = fieldNames |> slice.Sort
    let sortedFName = slice.Map npName frec.fields
                      |> slice.Sort
    sortedInput = sortedFName


let funionToGo (fu: UnionType) =
  fu.name

let lookupCase (fu: UnionType) (caseName: string) =
  lookupPairByName caseName fu.cases

// IntOrString_I
let unionCSName (unionName: string) (caseName: string) =
  unionName + "_" + caseName

let fSliceToGo (fs: SliceType) (toGo:FType->string) =
  "[]" + (toGo fs.elemType)

let FTypeToGo (ft:FType) : string =
  match ft with
  | FInt -> "int"
  | FBool -> "bool"
  | FString -> "string"    
  | FUnit -> "" // When use as return type in Go, "" is suitable.
  | FFunc ft -> funcTypeToGo ft FTypeToGo
  | FRecord fr -> recordTypeToGo fr
  | FUnion fu -> funionToGo fu
  | FExtType fe -> fe // for external type with typename fe, use that type name as is.
  | FSlice fs -> fSliceToGo fs FTypeToGo
  | FPreUsed fp -> fp
  | FTypeVar fp -> fp.name
