package main

import frt
import buf
import slice
import strings

type FType =
| FInt
| FString
| FUnit
| FUnresolved
| FFunc of FuncType
| FRecord of RecordType
| FUnion of UnionType
| FExtType of string
| FSlice of SliceType
and SliceType = {elemType: FType}
and FuncType = {targets: []FType}
and NameTypePair = {name: string; ftype: FType}
and RecordType = {name: string; fiedls: []NameTypePair}
and UnionType = {name: string; cases: []NameTypePair}

/*
F# valid def.

type FType =
| FInt
| FString
| FUnit
| FUnresolved
| FFunc of FuncType
| FRecord of RecordType
| FUnion of UnionType
| FCustom of string
| FSlice of SliceType
and NameTypePair = {name: string; ftype: FType}
and RecordType = {name: string; fiedls: NameTypePair[]}
and UnionType = {name: string; cases: NameTypePair[]}
and FuncType = {targets: FType[]}
and SliceType = {elemType: FType}

*/


let IsUnresolved (ft:FType) =
  match ft with
  | FUnresolved -> true
  | _ -> false


let fargs (ft:FuncType) =
  let l = slice.Length ft.targets
  ft.targets |> slice.Take (l-1)

let FFuncToGo (ft:FuncType) (toGo:FType->string) =
  let last = slice.Last ft.targets
  let args = fargs ft
  let bw = buf.New ()
  buf.Write bw "func ("
  args |> slice.Map toGo |> strings.Concat "," |> buf.Write bw
  buf.Write bw ")"
  let ret = match last with
            | FUnit -> ""
            | _ -> " " + (toGo last)
  buf.Write bw ret
  buf.String bw

let FTypeToGo (ft:FType) : string =
  match ft with
  | FInt -> "int"
  | FString -> "string"    
  | FUnit -> "" // When use as return type in Go, "" is suitable.
  | FUnresolved -> "" // This case is error. Just return "" for a while.
  | FFunc ft -> FFuncToGo ft FTypeToGo
  | FRecord _ -> ""
  | FUnion _ -> ""
  | FExtType fe -> fe // for external type with typename fe, use that type name as is.
  | FSlice _ -> ""

