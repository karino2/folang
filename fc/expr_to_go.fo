package main

import frt
import slice
import buf
import strings

// wrapper types.
package_info _ =
  let reinterpretEscape: string->string


let rgFVToGo  (toGo: Expr->string) (fvPair: NEPair) =
  let fn = fvPair.name
  let fv = fvPair.expr
  let fvGo = toGo fv
  fn + ": " + fvGo

let rgToGo (toGo: Expr->string) (rg:RecordGen) =
  let rtype = rg.recordType
  let b = buf.New ()
  frStructName rtype |> buf.Write b
  buf.Write b "{"
  let fvGo = rg.fieldsNV
             |> slice.Map (rgFVToGo toGo)
             |> strings.Concat ", "
  buf.Write b fvGo
  buf.Write b "}"
  buf.String b

/*

  blockToGo implementation.

*/

/*
  []Stmt+Expr -> []GoStmt+ return Expr.
*/
let buildReturn (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (stmts:[]Stmt) (lastExpr: Expr) =
  let stmtGos = slice.Map sToGo stmts |> strings.Concat "\n"
  let lastGo = match lastExpr with
              | EReturnableExpr re -> reToGoRet re
              | _ ->
                let mayReturn = if ExprToType lastExpr = FUnit then "" else "return "
                let lg = eToGo lastExpr
                mayReturn + lg
  if stmtGos = "" then
    lastGo
  else
    stmtGos + "\n" + lastGo


let wrapFunc (toGo: FType->string) (rtype:FType) (goReturnBody:string) =
  let b = buf.New ()
  buf.Write b "(func () "
  toGo rtype |> buf.Write b
  buf.Write b " {\n"
  buf.Write b goReturnBody
  buf.Write b"})"
  buf.String b

let wrapFunCall (toGo: FType->string) (rtype:FType) (goReturnBody:string) =
  let wf = wrapFunc toGo rtype goReturnBody
  wf + "()"

let lbToGo (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (lb:LazyBlock) =
  let returnBody = buildReturn sToGo eToGo reToGoRet lb.stmts lb.finalExpr
  let rtype = ExprToType lb.finalExpr
  wrapFunc FTypeToGo rtype returnBody

let blockToGoReturn (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (block:Block) =
  buildReturn sToGo eToGo reToGoRet block.stmts block.finalExpr

let blockToGo (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (block:Block) =
  let goRet = blockToGoReturn sToGo eToGo reToGoRet block
  let rtype = ExprToType block.finalExpr
  wrapFunCall FTypeToGo rtype goRet 

/*

  MatchExprToGo implementation

*/

/*
Build following case header. (If unit or _ variable, generate code appropriately.)

  case IntOrBool_I:
    [varName] := tmpV
*/
let mpToCaseHeader (uname: string) (mp: MatchPattern) (tmpVarName: string) =
  let b = buf.New ()
  buf.Write b "case "
  unionCSName uname mp.caseId |> buf.Write b
  buf.Write b ":\n"
  if mp.varName <> "_" && mp.varName <> "" then
    buf.Write b mp.varName
    buf.Write b " := "
    buf.Write b tmpVarName
    buf.Write b ".Value"
    buf.Write b "\n"
  buf.String b

/*
 btogRet is bounded blockToGoReturn.

 Generate following codes.

case IntOrBool_I:
	[varName] := tmpV
	body...

or

default:
   body...

*/
let mrToCase (btogRet: Block->string) (uname: string) (tmpVarName: string) (mr: MatchRule)  =
  let b = buf.New ()
  let mp = mr.pattern
  let cheader = if mp.caseId = "_" then
                  "default:\n"
                else
                  mpToCaseHeader uname mp tmpVarName
  buf.Write b cheader
  btogRet mr.body |> buf.Write b
  buf.Write b "\n"
  buf.String b  

let mrHasNoCaseVar (mr: MatchRule) =
  let pat = mr.pattern
  pat.caseId = "_" || pat.varName = "" || pat.varName = "_"

/*
  If atlease one value or not (if not, tmp var is not necessary).
*/
let meHasCaseVar (me:MatchExpr) =
  not (slice.Forall mrHasNoCaseVar me.rules)

let mrIsDefault (mr:MatchRule) =
  let pat = mr.pattern
  pat.caseId = "_"


let meToGoReturn (toGo: Expr->string) (btogRet: Block->string) (me:MatchExpr) =
  let ttype = ExprToType me.target
  let uttype = GoEval<UnionType> "ttype.(FType_FUnion).Value" // for non UnionType, NYI.
  let hasCaseVar = meHasCaseVar me
  let hasDefault = slice.Forany mrIsDefault me.rules
  let tmpVarName = if hasCaseVar then uniqueTmpVarName () else ""
  let mrtocase = mrToCase btogRet uttype.name tmpVarName
  let b = buf.New ()
  buf.Write b "switch "
  if hasCaseVar then
    buf.Write b tmpVarName
    buf.Write b " := "
  buf.Write b "("
  toGo me.target |> buf.Write b 
  buf.Write b ").(type){\n"
  slice.Map mrtocase me.rules
   |> strings.Concat ""
   |> buf.Write b
  if not hasDefault then
     buf.Write b "default:\npanic(\"Union pattern fail. Never reached here.\")\n"
  buf.Write b "}"
  buf.String b

let meToExpr (me:MatchExpr) =
  MatchExpr me |> EReturnableExpr

let meToGo (toGo: Expr->string) (btogRet: Block->string) (me:MatchExpr) =
  let goret = meToGoReturn toGo btogRet me
  let rtype = ExprToType (meToExpr me)
  wrapFunCall FTypeToGo rtype goret

/*

  ReturnableExpr to Go implementation.

*/

let reToGoReturn (sToGo: Stmt->string) (eToGo: Expr->string) (rexpr:ReturnableExpr) : string=
  let rtgr = reToGoReturn sToGo eToGo
  let btogoRet = blockToGoReturn sToGo eToGo rtgr
  match rexpr with
  | Block b -> blockToGoReturn sToGo eToGo rtgr b
  | MatchExpr me -> meToGoReturn eToGo btogoRet me

let reToGo (sToGo: Stmt->string) (eToGo: Expr->string) (rexpr:ReturnableExpr) : string=
  let rtgr = reToGoReturn sToGo eToGo
  let btogRet = blockToGoReturn sToGo eToGo rtgr
  match rexpr with
  | Block b -> blockToGo sToGo eToGo rtgr b
  | MatchExpr me -> meToGo eToGo btogRet me

/*

FunCallToGo

*/


let ftiToParamName (i:int) (ft:FType) =
  frt.Sprintf1 "_r%d" i

// ("_r0", FInt) -> "_r0 int"
let ntpairToParam (tGo:FType->string) (ntp: string*FType) =
  let tpgo = frt.Snd ntp |> tGo 
  let name = frt.Fst ntp
  name + " " + tpgo

let fcPartialApplyGo (tGo:FType->string) (eGo:Expr->string) (fc:FunCall) =
  let funcType = fcToFuncType fc
  let fargTypes = fargs funcType
  let argNum = slice.Length fc.args
  let restTypes = slice.Skip argNum fargTypes
  let restParamNames = slice.Mapi ftiToParamName restTypes
  let b = buf.New ()
  buf.Write b "(func (" // OK
  slice.Zip restParamNames restTypes |> slice.Map (ntpairToParam tGo)
  |> strings.Concat ", " |> buf.Write b
  buf.Write b ") "
  let fret = freturn funcType
  if fret = FUnit then
    buf.Write b "{ "
  else
    tGo fret |> buf.Write b
    buf.Write b "{ return "
  buf.Write b fc.targetFunc.name
  buf.Write b "("
  slice.Map eGo fc.args |> strings.Concat ", " |> buf.Write b
  buf.Write b ", "
  strings.Concat ", " restParamNames |> buf.Write b
  buf.Write b ") })"
  buf.String b

let fcUnitArgOnly (fc:FunCall) =
  let al = slice.Length fc.args
  if al = 1 then
    Unit = slice.Head fc.args 
  else
    false

let fcFullApplyGo (eGo:Expr->string) (fc:FunCall) =
  let b = buf.New ()
  buf.Write b fc.targetFunc.name
  buf.Write b "("
  if not (fcUnitArgOnly fc) then
    slice.Map eGo fc.args |> strings.Concat ", " |> buf.Write b
  buf.Write b ")"
  buf.String b

let fcToGo (tGo:FType->string) (eGo:Expr->string) (fc:FunCall) =
  let funcType = fcToFuncType fc
  let fargTypes = fargs funcType
  let al = slice.Length fc.args
  let tal = slice.Length fargTypes
  if al > tal then GoEval "panic(\"Too many argument\")"
  if al < tal then
    fcPartialApplyGo tGo eGo fc
  else
    fcFullApplyGo eGo fc

let ExprToGo (sToGo: Stmt->string) (expr:Expr) : string =
  let eToGo = ExprToGo sToGo
  match expr with
  | BoolLiteral b -> frt.Sprintf1 "%t" b
  | GoEvalExpr ge -> reinterpretEscape ge.goStmt
  | StringLiteral s -> frt.Sprintf1 "\"%s\"" s
  | IntImm i -> frt.Sprintf1 "%d" i
  | Unit -> ""
  | FieldAccess fa -> fa.targetName + "." + fa.fieldName
  | Var v -> v.name
  | RecordGen rg -> rgToGo eToGo rg
  | EReturnableExpr re -> reToGo sToGo eToGo re
  | FunCall fc -> fcToGo FTypeToGo eToGo fc

