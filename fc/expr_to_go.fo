package main

import frt
import slice
import buf
import strings

// wrapper types.
package_info _ =
  let reinterpretEscape: string->string
  let uniqueTmpVarName: ()->string


let rgFVToGo  (toGo: Expr->string) (fvPair: NEPair) =
  let fn = fvPair.Name
  let fv = fvPair.Expr
  let fvGo = toGo fv
  fn + ": " + fvGo

let rgToGo (toGo: Expr->string) (rg:RecordGen) =
  let rtype = rg.RecordType
  let b = buf.New ()
  frStructName rtype |> buf.Write b
  buf.Write b "{"
  let fvGo = rg.FieldsNV
             |> slice.Map (rgFVToGo toGo)
             |> strings.Concat ", "
  buf.Write b fvGo
  buf.Write b "}"
  buf.String b

/*

  blockToGo implementation.

*/

/*
  []Stmt+Expr -> []GoStmt+ return Expr.
*/
let buildReturn (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (stmts:[]Stmt) (lastExpr: Expr) =
  let stmtGos = slice.Map sToGo stmts |> strings.Concat "\n"
  let lastGo = match lastExpr with
              | EReturnableExpr re -> reToGoRet re
              | _ ->
                let mayReturn = if ExprToType lastExpr = FUnit then "" else "return "
                let lg = eToGo lastExpr
                mayReturn + lg
  if stmtGos = "" then
    lastGo
  else
    stmtGos + "\n" + lastGo


let wrapFunc (toGo: FType->string) (rtype:FType) (goReturnBody:string) =
  let b = buf.New ()
  buf.Write b "(func () "
  toGo rtype |> buf.Write b
  buf.Write b " {\n"
  buf.Write b goReturnBody
  buf.Write b"})"
  buf.String b

let wrapFunCall (toGo: FType->string) (rtype:FType) (goReturnBody:string) =
  let wf = wrapFunc toGo rtype goReturnBody
  wf + "()"

let blockToGoReturn (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (block:Block) =
  buildReturn sToGo eToGo reToGoRet block.Stmts block.FinalExpr

let blockToGo (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (block:Block) =
  let goRet = blockToGoReturn sToGo eToGo reToGoRet block
  let rtype = ExprToType block.FinalExpr
  wrapFunCall FTypeToGo rtype goRet 

let lbToGo (bToRet: Block->string) (lb:LazyBlock) =
  let returnBody = bToRet lb.Block
  let rtype = ExprToType lb.Block.FinalExpr
  wrapFunc FTypeToGo rtype returnBody


/*

  MatchExprToGo implementation

*/

/*
Build following case header. (If unit or _ variable, generate code appropriately.)

  case IntOrBool_I:
    [VarName] := tmpV
*/
let mpToCaseHeader (uname: string) (mp: MatchPattern) (tmpVarName: string) =
  let b = buf.New ()
  buf.Write b "case "
  unionCSName uname mp.CaseId |> buf.Write b
  buf.Write b ":\n"
  if mp.VarName <> "_" && mp.VarName <> "" then
    buf.Write b mp.VarName
    buf.Write b " := "
    buf.Write b tmpVarName
    buf.Write b ".Value"
    buf.Write b "\n"
  buf.String b

/*
 btogRet is bounded blockToGoReturn.

 Generate following codes.

case IntOrBool_I:
	[VarName] := tmpV
	body...

or

default:
   body...

*/
let mrToCase (btogRet: Block->string) (uname: string) (tmpVarName: string) (mr: MatchRule)  =
  let b = buf.New ()
  let mp = mr.Pattern
  let cheader = if mp.CaseId = "_" then
                  "default:\n"
                else
                  mpToCaseHeader uname mp tmpVarName
  buf.Write b cheader
  btogRet mr.Body |> buf.Write b
  buf.Write b "\n"
  buf.String b  

let mrHasNoCaseVar (mr: MatchRule) =
  let pat = mr.Pattern
  pat.CaseId = "_" || pat.VarName = "" || pat.VarName = "_"

/*
  If atlease one value or not (if not, tmp var is not necessary).
*/
let meHasCaseVar (me:MatchExpr) =
  not (slice.Forall mrHasNoCaseVar me.Rules)

let mrIsDefault (mr:MatchRule) =
  let pat = mr.Pattern
  pat.CaseId = "_"


let meToGoReturn (toGo: Expr->string) (btogRet: Block->string) (me:MatchExpr) =
  let ttype = ExprToType me.Target
  let uttype = GoEval<UnionType> "ttype.(FType_FUnion).Value" // for non UnionType, NYI.
  let uname = utName uttype
  let hasCaseVar = meHasCaseVar me
  let hasDefault = slice.Forany mrIsDefault me.Rules
  let tmpVarName = if hasCaseVar then uniqueTmpVarName () else ""
  let mrtocase = mrToCase btogRet uname tmpVarName
  let b = buf.New ()
  buf.Write b "switch "
  if hasCaseVar then
    buf.Write b tmpVarName
    buf.Write b " := "
  buf.Write b "("
  toGo me.Target |> buf.Write b 
  buf.Write b ").(type){\n"
  slice.Map mrtocase me.Rules
   |> strings.Concat ""
   |> buf.Write b
  if not hasDefault then
     buf.Write b "default:\npanic(\"Union pattern fail. Never reached here.\")\n"
  buf.Write b "}"
  buf.String b

let meToExpr (me:MatchExpr) =
  RMatchExpr me |> EReturnableExpr

let meToGo (toGo: Expr->string) (btogRet: Block->string) (me:MatchExpr) =
  let goret = meToGoReturn toGo btogRet me
  let rtype = ExprToType (meToExpr me)
  wrapFunCall FTypeToGo rtype goret

/*

  ReturnableExpr to Go implementation.

*/

let reToGoReturn (sToGo: Stmt->string) (eToGo: Expr->string) (rexpr:ReturnableExpr) : string=
  let rtgr = reToGoReturn sToGo eToGo
  let btogoRet = blockToGoReturn sToGo eToGo rtgr
  match rexpr with
  | RBlock b -> blockToGoReturn sToGo eToGo rtgr b
  | RMatchExpr me -> meToGoReturn eToGo btogoRet me

let reToGo (sToGo: Stmt->string) (eToGo: Expr->string) (rexpr:ReturnableExpr) : string=
  let rtgr = reToGoReturn sToGo eToGo
  let btogRet = blockToGoReturn sToGo eToGo rtgr
  match rexpr with
  | RBlock b -> blockToGo sToGo eToGo rtgr b
  | RMatchExpr me -> meToGo eToGo btogRet me

/*

FunCallToGo

*/


let ftiToParamName (i:int) (ft:FType) =
  frt.Sprintf1 "_r%d" i

// ("_r0", FInt) -> "_r0 int"
let ntpairToParam (tGo:FType->string) (ntp: string*FType) =
  let tpgo = frt.Snd ntp |> tGo 
  let name = frt.Fst ntp
  name + " " + tpgo

let varRefToGo (tGo:FType->string) (vr:VarRef) =
  match vr with
  | VRVar v -> v.Name
  | VRSVar sv ->
    let tlis = sv.SpecList
                |> slice.Map tGo
                |> strings.Concat ", "
    sv.Var.Name + "[" + tlis + "]"

let fcPartialApplyGo (tGo:FType->string) (eGo:Expr->string) (fc:FunCall) =
  let funcType = fcToFuncType fc
  let fargTypes = fargs funcType
  let argNum = slice.Length fc.Args
  let restTypes = slice.Skip argNum fargTypes
  let restParamNames = slice.Mapi ftiToParamName restTypes
  let b = buf.New ()
  buf.Write b "(func (" // OK
  slice.Zip restParamNames restTypes |> slice.Map (ntpairToParam tGo)
  |> strings.Concat ", " |> buf.Write b
  buf.Write b ") "
  let fret = freturn funcType
  if fret = FUnit then
    buf.Write b "{ "
  else
    tGo fret |> buf.Write b
    buf.Write b "{ return "
  varRefToGo tGo fc.TargetFunc |> buf.Write b
  buf.Write b "("
  slice.Map eGo fc.Args |> strings.Concat ", " |> buf.Write b
  buf.Write b ", "
  strings.Concat ", " restParamNames |> buf.Write b
  buf.Write b ") })"
  buf.String b

let fcUnitArgOnly (fc:FunCall) =
  let al = slice.Length fc.Args
  if al = 1 then
    EUnit = slice.Head fc.Args 
  else
    false        

let fcFullApplyGo (tGo:FType->string) (eGo:Expr->string) (fc:FunCall) =
  let b = buf.New ()
  varRefToGo tGo fc.TargetFunc |> buf.Write b
  buf.Write b "("
  if not (fcUnitArgOnly fc) then
    slice.Map eGo fc.Args |> strings.Concat ", " |> buf.Write b
  buf.Write b ")"
  buf.String b

let fcToGo (tGo:FType->string) (eGo:Expr->string) (fc:FunCall) =
  let funcType = fcToFuncType fc
  let fargTypes = fargs funcType
  let al = slice.Length fc.Args
  let tal = slice.Length fargTypes
  if al > tal then GoEval "panic(\"Too many argument\")"
  if al < tal then
    fcPartialApplyGo tGo eGo fc
  else
    fcFullApplyGo tGo eGo fc

let sliceToGo (tGo:FType->string) (eGo:Expr->string) (exprs: []Expr) =
  let b = buf.New ()
  buf.Write b "("
  ESlice exprs |> ExprToType |> tGo |> buf.Write b
  buf.Write b "{"
  slice.Map eGo exprs |> strings.Concat "," |> buf.Write b
  buf.Write b "}"
  buf.Write b ")"
  buf.String b

let tupleToGo (eGo:Expr->string) (exprs: []Expr) =
  let b = buf.New ()
  buf.Write b "frt.NewTuple2("
  slice.Map eGo exprs
  |> strings.Concat ", "
  |> buf.Write b
  buf.Write b ")"
  buf.String b

let binOpToGo (eGo:Expr->string) (binOp:BinOpCall) =
  let b = buf.New ()
  buf.Write b "("
  [binOp.Lhs; binOp.Rhs]
  |> slice.Map eGo
  |> strings.Concat binOp.Op
  |> buf.Write b
  buf.Write b ")"
  buf.String b

let faToGo (eGo:Expr->string) (fa:FieldAccess) =
  let target = eGo fa.TargetExpr
  target + "." + fa.FieldName

let paramsToGo (pm: Var) =
   let ts = FTypeToGo pm.Ftype
   pm.Name + " " + ts

let lambdaToGo (bToGoRet: Block->string) (le:LambdaExpr) =
  let b = buf.New ()
  buf.Write b "func ("
  slice.Map paramsToGo le.Params
  |> strings.Concat ", "
  |> buf.Write b
  buf.Write b ")"
  blockToType ExprToType le.Body |> FTypeToGo |> buf.Write b
  buf.Write b "{\n"
  bToGoRet le.Body |> buf.Write b
  buf.Write b "\n}"
  buf.String b


  

let ExprToGo (sToGo: Stmt->string) (expr:Expr) : string =
  let eToGo = ExprToGo sToGo
  let reToGoRet = reToGoReturn sToGo eToGo 
  let bToGoRet = blockToGoReturn sToGo eToGo reToGoRet
  match expr with
  | EBoolLiteral b -> frt.Sprintf1 "%t" b
  | EGoEvalExpr ge -> reinterpretEscape ge.GoStmt
  | EStringLiteral s -> frt.Sprintf1 "\"%s\"" s
  | EIntImm i -> frt.Sprintf1 "%d" i
  | EUnit -> ""
  | EFieldAccess fa -> faToGo eToGo fa
  | EVarRef vr ->varRefName vr
  | ESlice es -> sliceToGo FTypeToGo eToGo es
  | ETupleExpr es -> tupleToGo eToGo es
  | ELambda le -> lambdaToGo bToGoRet le
  | EBinOpCall bop -> binOpToGo eToGo bop
  | ERecordGen rg -> rgToGo eToGo rg
  | EReturnableExpr re -> reToGo sToGo eToGo re
  | EFunCall fc -> fcToGo FTypeToGo eToGo fc
  | ELazyBlock lb ->
    lbToGo bToGoRet lb

