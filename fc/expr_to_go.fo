package main

import frt
import slice
import buf
import strings


let rgFVToGo  (toGo: Expr->string) (fvPair: string*Expr) =
  let fn = frt.Fst fvPair
  let fv = frt.Snd fvPair
  let fvGo = toGo fv
  fn + ": " + fvGo

let rgToGo (toGo: Expr->string) (rg:RecordGen) =
  let rtype = rg.recordType
  let b = buf.New ()
  frStructName rtype |> buf.Write b
  buf.Write b "{"
  let fvGo = slice.Zip rg.fieldNames rg.fieldValues
             |> slice.Map (rgFVToGo toGo)
             |> strings.Concat ", "
  buf.Write b fvGo
  buf.Write b "}"
  buf.String b

/*

  blockToGo implementation.

*/

/*
  []Stmt+Expr -> []GoStmt+ return Expr.
*/
let buildReturn (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (stmts:[]Stmt) (lastExpr: Expr) =
  let stmtGos = slice.Map sToGo stmts |> strings.Concat "\n"
  let lastGo = match lastExpr with
              | ReturnableExpr re -> reToGoRet re
              | _ ->
                let mayReturn = if ExprToType lastExpr = FUnit then "" else "return "
                let lg = eToGo lastExpr
                mayReturn + lg
  stmtGos + "\n" + lastGo


let wrapFunc (toGo: FType->string) (rtype:FType) (goReturnBody:string) =
  let b = buf.New ()
  buf.Write b "(func () "
  toGo rtype |> buf.Write b
  buf.Write b " {\n"
  buf.Write b goReturnBody
  buf.Write b"})"
  buf.String b

let wrapFunCall (toGo: FType->string) (rtype:FType) (goReturnBody:string) =
  let wf = wrapFunc toGo rtype goReturnBody
  wf + "()"

let lbToGo (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (lb:LazyBlock) =
  let returnBody = buildReturn sToGo eToGo reToGoRet lb.stmts lb.finalExpr
  let rtype = ExprToType lb.finalExpr
  wrapFunc FTypeToGo rtype returnBody

let blockToGoReturn (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (block:Block) =
  buildReturn sToGo eToGo reToGoRet block.stmts block.finalExpr

let blockToGo (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (block:Block) =
  let goRet = blockToGoReturn sToGo eToGo reToGoRet block
  let rtype = ExprToType block.finalExpr
  wrapFunCall FTypeToGo rtype goRet 

/*

  MatchExprToGo implementation

*/

/*
Build following case header. (If unit or _ variable, generate code appropriately.)

  case IntOrBool_I:
    [varName] := tmpV
*/
let mpToCaseHeader (uname: string) (mp: MatchPattern) (tmpVarName: string) =
  let b = buf.New ()
  buf.Write b "case "
  unionCaseStructName uname mp.caseId |> buf.Write b
  buf.Write b ":\n"
  if mp.varName <> "_" && mp.varName <> "" then
    buf.Write b mp.varName
    buf.Write b " := "
    buf.Write b tmpVarName
    buf.Write b ".Value"
    buf.Write b "\n"
  buf.String b

/*
 btogRet is bounded blockToGoReturn.

 Generate following codes.)

case IntOrBool_I:
	[varName] := tmpV
	body...

or

default:
   body...

*/
let mrToCase (btogRet: Block->string) (uname: string) (tmpVarName: string) (mr: MatchRule)  =
  let b = buf.New ()
  let mp = mr.pattern
  let cheader = if mp.caseId = "_" then
                  "default:\n"
                else
                  mpToCaseHeader uname mp tmpVarName
  buf.Write b cheader
  btogRet mr.body |> buf.Write b
  buf.Write b "\n"
  buf.String b  

let mrHasCaseVar (mr: MatchRule) =
  let pat = mr.pattern
  pat.caseId <> "_" && pat.varName <> "" && pat.varName <> "_"

/*
  If atlease one value or not (if not, tmp var is not necessary).
*/
let meHasCaseVar (me:MatchExpr) =
  slice.Forall mrHasCaseVar me.rules

let mrIsDefault (mr:MatchRule) =
  let pat = mr.pattern
  pat.caseId = "_"


let meToGoReturn (toGo: Expr->string) (btogRet: Block->string) (me:MatchExpr) =
  let ttype = ExprToType me.target
  let uttype = GoEval<UnionType> "ttype.(FType_FUnion).Value" // for non UnionType, NYI.
  let hasCaseVar = meHasCaseVar me
  let hasDefault = slice.Forany mrIsDefault me.rules
  let tmpVarName = if hasCaseVar then uniqueTmpVarName () else ""
  let mrtocase = mrToCase btogRet uttype.name tmpVarName
  let b = buf.New ()
  buf.Write b "switch "
  if hasCaseVar then
    buf.Write b tmpVarName
    buf.Write b " := "
  buf.Write b "("
  toGo me.target |> buf.Write b 
  buf.Write b ").(type){\n"
  slice.Map mrtocase me.rules
   |> strings.Concat ""
   |> buf.Write b
  if not hasDefault then
     buf.Write b "default:\npanic(\"Union pattern fail. Never reached here.\")\n"
  buf.Write b "}"
  buf.String b

let meToExpr (me:MatchExpr) =
  MatchExpr me |> ReturnableExpr

let meToGo (toGo: Expr->string) (btogRet: Block->string) (me:MatchExpr) =
  let goret = meToGoReturn toGo btogRet me
  let rtype = ExprToType (meToExpr me)
  wrapFunCall FTypeToGo rtype goret

/*

  ReturnableExpr to Go implementation.

*/

let reToGoReturn (sToGo: Stmt->string) (eToGo: Expr->string) (rexpr:ReturnableExpr) : string=
  let rtgr = reToGoReturn sToGo eToGo
  let btogoRet = blockToGoReturn sToGo eToGo rtgr
  match rexpr with
  | Block b -> blockToGoReturn sToGo eToGo rtgr b
  | MatchExpr me -> meToGoReturn eToGo btogoRet me

let reToGo (sToGo: Stmt->string) (eToGo: Expr->string) (rexpr:ReturnableExpr) : string=
  let rtgr = reToGoReturn sToGo eToGo
  let btogRet = blockToGoReturn sToGo eToGo rtgr
  match rexpr with
  | Block b -> blockToGo sToGo eToGo rtgr b
  | MatchExpr me -> meToGo eToGo btogRet me

/*
TODO: FunCallToGo
*/

let ExprToGo (sToGo: Stmt->string) (expr:Expr) : string =
  let eToGo = ExprToGo sToGo
  match expr with
  | BoolLiteral b -> frt.Sprintf1 "%t" b
  | GoEval ge -> ge.goStmt
  | StringLiteral s -> frt.Sprintf1 "\\\"%s\\\"" s
  | IntImm i -> frt.Sprintf1 "%d" i
  | Unit -> ""
  | FieldAccess fa -> fa.targetName + "." + fa.fieldName
  | Var v -> v.name
  | RecordGen rg -> rgToGo eToGo rg
  | ReturnableExpr re -> reToGo sToGo eToGo re
  | FunCall _ -> "NYI"

