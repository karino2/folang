package main
import frt
import buf
import slice
import strings

let imToGo (pn:string) =
  frt.Sprintf1 "import \"%s\"" pn

let pmToGo (pn:string) =
  frt.Sprintf1 "package %s" pn

/*

  LetFuncDef to Go implementation.

*/

let paramsToGo (pm: Var) =
   let ts = FTypeToGo pm.ftype
   pm.name + " " + ts

/*
  Emit parameters of func defs like following:
  a int, b string, c []int
*/
let lfdParamsToGo (lfd:LetFuncDef) =
   lfd.params |> slice.Map paramsToGo |> strings.Concat ", "

let lfdToGo (bToGoRet: Block->string) (lfd:LetFuncDef) =
  let b = buf.New ()
  buf.Write b "func "
  buf.Write b lfd.fvar.name
  buf.Write b "("
  lfdParamsToGo lfd |> buf.Write b
  buf.Write b ") "
  blockToType ExprToType lfd.body |> FTypeToGo |> buf.Write b
  buf.Write b "{\n"
  bToGoRet lfd.body |> buf.Write b
  buf.Write b "\n}"
  buf.String b

let rfdToGo (bToGoRet: Block->string) (rfd:RootFuncDef) =
  lfdToGo bToGoRet rfd.lfd


let lvdToGo (eToGo: Expr->string) (lvd:LetVarDef) =
  let rhs = eToGo lvd.rhs
  lvd.lvar.name + " := " + rhs

/*
  RecordDef to Go implementation.
*/

let rdffieldToGo (field: NameTypePair) =
  "  " + field.name + " " + (FTypeToGo field.ftype)

let rdfToGo (rdf:RecordDef) =
  let b = buf.New ()
  buf.Write b "type "
  buf.Write b rdf.name
  buf.Write b " struct {\n"
  rdf.fields |> slice.Map rdffieldToGo |> strings.Concat "\n" |> buf.Write b
  buf.Write b "\n}" 
  buf.String b

/*
   UnionDef to Go implementation.
*/

/*
Union implementation.
For following code:
type IntOrString =

	| I of int
	| B of bool

The result becomes following three types.

- IntOrString interface
- IntOrString_I struct (with Value int)
- IntOrString_B struct (with Value bool)

We call IntOrString_I "case struct of I".
*/

/*
	type IntOrString interface {
	  IntOrString_Union()
	}
*/
let udUnionDef (ud:UnionDef) =
  let b = buf.New ()
  buf.Write b "type "
  buf.Write b ud.name
  buf.Write b " interface {\n"
  buf.Write b "  "
  buf.Write b ud.name
  buf.Write b "_Union()\n"
  buf.Write b "}\n"
  buf.String b

/*
func (IntOrString_I) [method]
*/
let csToConformMethod (uname:string) (method:string) (cas: NameTypePair) =
  let csname = unionCSName uname cas.name
  "func (" + csname + ") " + method

/*
func (IntOrString_I) IntOrString_Union(){}
func (IntOrString_B) IntOrString_Union(){}
*/
let udCSConformMethods (ud:UnionDef) =
  let method = ud.name + "_Union(){}\n"
  ud.cases |> slice.Map (csToConformMethod ud.name method) |> strings.Concat ""

/*
	type IntOrString_I struct {
	   Value int
	}
*/
let udCSDef (ud:UnionDef) (cas: NameTypePair) =
  let b = buf.New ()
  buf.Write b "type "
  unionCSName ud.name cas.name |> buf.Write b
  buf.Write b " struct {\n"
  if cas.ftype <> FUnit then
    buf.Write b "  Value "
    FTypeToGo cas.ftype |> buf.Write b
    buf.Write b "\n"
  buf.Write b "}\n"
  buf.String b

// New_IntOrString_I
let csConstructorName  (unionName: string) (cas: NameTypePair) =
   "New_" + (unionCSName unionName cas.name)

/*
CS Constructor, function case.

func New_IntOrString_I(v int) IntOrString { return IntOrString_I{v} }
*/
let csConstructFunc (uname:string) (cas: NameTypePair) =
  let b = buf.New ()
  buf.Write b "func "
  csConstructorName uname cas |> buf.Write b
  buf.Write b "(v "
  FTypeToGo cas.ftype |> buf.Write b
  buf.Write b ") "
  buf.Write b uname
  buf.Write b " { return "
  buf.Write b (unionCSName uname cas.name)
  buf.Write b "{v} }\n"
  buf.String b


/*
CS Constructor, variable case.

No arg case constructor case.
In this case, folang regard no arg func as variable.
So the result must be following:

var New_IntOrString_I IntOrString = &IntOrString_I{}
*/
let csConstructVar (uname:string) (cas: NameTypePair) =
  let b = buf.New ()
  buf.Write b "var "
  csConstructorName uname cas |> buf.Write b
  buf.Write b " "
  buf.Write b uname
  buf.Write b " = "
  buf.Write b (unionCSName uname cas.name)
  buf.Write b "{}\n"
  buf.String b

let csConstruct (uname:string) (cas: NameTypePair) =
  if cas.ftype = FUnit then
    csConstructVar uname cas
  else
    csConstructFunc uname cas

let caseToGo (ud:UnionDef) (cas: NameTypePair) =
  let sdf = udCSDef ud cas
  let csdf = csConstruct ud.name cas
  sdf + "\n" + csdf + "\n"

let udfToGo (ud:UnionDef) =
  let b = buf.New ()
  udUnionDef ud |> buf.Write b
  buf.Write b "\n"
  udCSConformMethods ud |> buf.Write b
  buf.Write b "\n"
  ud.cases |> slice.Map (caseToGo ud) |> strings.Concat "" |> buf.Write b
  buf.String b

/*
  DefStmt to Go, MultpleDefs to Go
*/

let dsToGo (ds:DefStmt) =
   match ds with
   | DRecordDef rd -> rdfToGo rd
   | DUnionDef ud -> udfToGo ud

let mdToGo (md:MultipleDefs) =
  md.defs |>  slice.Map dsToGo |> strings.Concat "\n"

let StmtToGo (stmt:Stmt) : string=
  let eToGo = ExprToGo StmtToGo
  match stmt with
  | SLetVarDef lvd -> lvdToGo eToGo lvd
  | SExprStmt expr -> eToGo expr

let RootStmtToGo (rstmt:RootStmt) : string=
  let eToGo = ExprToGo StmtToGo
  let reToGoRet = reToGoReturn StmtToGo eToGo
  let bToGoRet = blockToGoReturn StmtToGo eToGo reToGoRet
  match rstmt with
  | RSImport im -> imToGo im
  | RSPackage pn -> pmToGo pn
  | RSPackageInfo -> ""
  | RSLetFuncDef lfd -> lfdToGo bToGoRet lfd
  | RSRootFuncDef rfd -> rfdToGo bToGoRet rfd
  | RSDefStmt ds -> dsToGo ds
  | RSMultipleDefs md -> mdToGo md



let RootStmtsToGo (rstmts:[]RootStmt) =
  slice.Map RootStmtToGo rstmts |> strings.Concat "\n\n" |> strings.AppendTail "\n"
