package main

import frt
import slice

/*
  GenFunc related
*/

// wrapper types.
package_info _ =
  type TypeVarDict
  let toTVDict: []string*TypeVar->TypeVarDict
  let tvdLookupNF: TypeVarDict->string->TypeVar


let tpname2tvtp (tvgen: ()->TypeVar) (tpname:string) =
  let tv = tvgen ()
  (tpname, tv)

/*
  TransformT FTypeVar and recomposite.
*/
let transTypeVarFType (transTV: TypeVar->FType) (ftp:FType) : FType =
  let recurse = transTypeVarFType transTV
  match ftp with
  | FTypeVar tv -> transTV tv
  | FSlice ts ->
    let et = recurse ts.elemType
    FSlice {SliceType.elemType = et}
  | FTuple ftup ->
    let nts = slice.Map recurse ftup.elemTypes
    {TupleType.elemTypes=nts}
    |> FTuple
  | FFunc fnt ->
    let nts = slice.Map recurse fnt.targets
    {FuncType.targets=nts}
    |> FFunc
  | _ -> ftp

let tpReplaceOne (tvd:TypeVarDict) (tv:TypeVar) =
  tvdLookupNF tvd tv.name |> FTypeVar

let tpreplace (tvd:TypeVarDict) (ft:FType) =
  transTypeVarFType (tpReplaceOne tvd) ft

let GenFunc (ff:FuncFactory) (tvgen: ()->TypeVar) =
  let tvd = slice.Map (tpname2tvtp tvgen) ff.tparams |> toTVDict
  let ntargets = slice.Map (tpreplace tvd) ff.targets
  {FuncType.targets=ntargets}

let GenFuncVar (vname:string) (ff:FuncFactory) (tvgen: ()->TypeVar) =
  let funct = GenFunc ff tvgen
  let ft = FFunc funct
  {Var.name=vname; ftype=ft}

let genBuiltinFunCall (tvgen: ()->TypeVar) (fname:string) (tpnames: []string) (targetTPs:[]FType) (args:[]Expr) =
  let ff = {tparams=tpnames; targets=targetTPs}
  let fvar = GenFuncVar fname ff tvgen
  {targetFunc=fvar; args=args}
  |> EFunCall

let newTvf (name:string) =
   {TypeVar.name=name}
   |> FTypeVar


/*
  Scope and Parser related
*/

// wrapper types.
package_info _ =
  type Scope
  let NewScope: ()->Scope
  let newScope: Scope->Scope
  let popScope: Scope->Scope
  let scDefVar: Scope->string->Var->()
  let scLookupVarFac: Scope->string->((()->TypeVar)->Var)*bool
  let scRegisterRecType: Scope->RecordType->()
  let scLookupRecord: Scope->[]string->RecordType*bool
  let scLookupRecordByName: Scope->string->RecordType*bool
  let scRegisterType: Scope->string->FType->()
  let scRegisterVarFac: Scope->string->((()->TypeVar)->Var)->()
  let scLookupType: Scope->string->FType*bool
  type TypeVarAllocator
  let NewTypeVarAllocator: ()->TypeVarAllocator
  let tvaToTypeVarGen: TypeVarAllocator->(()->TypeVar)
  let tvaReset: TypeVarAllocator->()
  let resetUniqueTmpCounter: ()->()
  let tvaListAlloced: TypeVarAllocator->[]TypeVar

type ParseState = {
  tkz: Tokenizer;
  scope: Scope;
  offsideCol: []int;
  tva: TypeVarAllocator;
  // typeDefCtx
}


// wrapper types. Use ParseState
package_info _ =
  let withPs<T>: ParseState->T->ParseState*T
  // inference from funcall to arg side is NYI.
  // let CnvL<T, U>: (T->T)->T*U->T*U
  // let CnvR<T, U>: (U->U)->T*U->T*U
  let CnvL<U>: (ParseState->ParseState)->ParseState*U->ParseState*U
  let CnvR<T, U>: (T->U)->ParseState*T->ParseState*U


let newParse (tkz:Tokenizer) (scope:Scope) (offCols:[]int) (tva:TypeVarAllocator) =
  {tkz=tkz; scope=scope; offsideCol=offCols; tva=tva}

let psWithTkz (org:ParseState) (tkz:Tokenizer) =
  newParse tkz org.scope org.offsideCol org.tva

let psWithScope (org:ParseState) (nsc:Scope) =
  newParse org.tkz nsc org.offsideCol org.tva

let psWithOffside (org:ParseState) (offs:[]int) =
  newParse org.tkz org.scope offs org.tva

let psTypeVarGen (ps:ParseState) =
  tvaToTypeVarGen ps.tva

let psPushScope (org:ParseState) =
  newScope org.scope |> psWithScope org

let psPopScope (org:ParseState) =
  popScope org.scope |> psWithScope org

let psCurOffside (ps:ParseState) =
  slice.Last ps.offsideCol

let psCurCol (ps:ParseState) =
  ps.tkz.col

let psPushOffside (ps:ParseState) =
  let curCol = psCurCol ps
  if (psCurOffside ps) >= curCol then
    frt.Panic "Overrun offside rule"
  slice.PushLast curCol ps.offsideCol
  |> psWithOffside ps

let psPopOffside (ps:ParseState) =
  slice.PopLast ps.offsideCol
  |> psWithOffside ps

let initParse (src: string) =
  let tkz = newTkz src
  let scope = NewScope ()
  let offside = [0]
  let tva = NewTypeVarAllocator ()
  newParse tkz scope offside tva

let psCurrent (ps:ParseState) =
  ps.tkz.current

let psCurrentTT (ps:ParseState) =
  let tk = psCurrent ps
  tk.ttype

let psCurIs (expectTT: TokenType) (ps:ParseState) =
  (psCurrentTT ps) = expectTT

let psNext (ps:ParseState) =
  let ntk = tkzNext ps.tkz
  psWithTkz ps ntk

let psNextTT (ps:ParseState) =
  psNext ps |> psCurrentTT

let psNextNOL (ps:ParseState) =
  let ntk = tkzNextNOL ps.tkz
  psWithTkz ps ntk

let psSkipEOL (ps:ParseState) =
  if (psCurrentTT ps) = EOL then
    psNextNOL ps
  else
    ps


let psExpect (ttype:TokenType) (ps:ParseState) =
  let cur = psCurrent ps
  if cur.ttype <> ttype then
    frt.Panic("non expected token")
  ()

let psConsume (ttype:TokenType) (ps:ParseState) =
  psExpect ttype ps
  psNext ps


let psIdentName (ps:ParseState) =
  psExpect IDENTIFIER ps
  let cur = psCurrent ps
  cur.stringVal

let psStringVal (ps:ParseState) =
  psExpect STRING ps
  let cur = psCurrent ps
  cur.stringVal

let psStrNx (f: ParseState->string) (ps:ParseState) =
  let s = f ps
  let ps2 = psNext ps
  (ps2, s)


// psIdentName and Next
let psIdentNameNx (ps:ParseState) =
  psStrNx psIdentName ps

let psStringValNx (ps:ParseState) =
  psStrNx psStringVal ps


let psCurrentNx (ps:ParseState) =
  let tk = psCurrent ps
  let ps2 = psNext ps
  (ps2, tk)

let psCurrentTTNx (ps:ParseState) =
  let tt = psCurrentTT ps
  let ps2 = psNext ps
  (ps2, tt)

// NxL means NextNOL
let psIdentNameNxL (ps:ParseState) =
  psIdentNameNx ps |> CnvL psSkipEOL

let psStringValNxL (ps:ParseState) =
  psStringValNx ps |> CnvL psSkipEOL

let psCurrentNxL (ps:ParseState) =
  psCurrentNx ps |> CnvL psSkipEOL

let psCurrentTTNxL (ps:ParseState) =
  psCurrentTTNx ps |> CnvL psSkipEOL

let psResetTmpCtx (ps:ParseState) =
  resetUniqueTmpCounter ()
  tvaReset ps.tva
  ps


/*
UnionDef related utility.
*/

let udToUt (ud:UnionDef) =
  GoEval<UnionType> "UnionType(ud)"

let udToFUt (ud:UnionDef) =
  udToUt ud |> FUnion

/*
// New_IntOrString_I
let csConstructorName  (unionName: string) (cas: NameTypePair) =
*/
let csRegisterCtor (sc:Scope) (ud: UnionDef) (cas: NameTypePair) =
  let ctorName = csConstructorName ud.name cas
  let ut = udToFUt ud
  let v = match cas.ftype with
          | FUnit ->
            {Var.name=ctorName; ftype=ut}
          | _ ->
            let tps = [cas.ftype; ut]
            let funcTp = FFunc {targets=tps}
            {Var.name=ctorName; ftype=funcTp}
  scDefVar sc cas.name v

let udRegisterCsCtors (sc:Scope) (ud:UnionDef) =
  ud.cases |> slice.Iter (csRegisterCtor sc ud)

let udRegisterToScope (sc:Scope) (ud:UnionDef) =
  udRegisterCsCtors sc ud
  udToFUt ud |> scRegisterType sc ud.name

/*
PackageInfo related utility.
*/

package_info _ =
  let etdPut: extTypeDict->string->string->()
  let ffdPut: funcFacDict->string->FuncFactory->()
  let ffdKVs: funcFacDict->[]string*FuncFactory
  let etdKVs: extTypeDict->[]string*string

let piFullName (pi:PackageInfo) (name:string) =
  if pi.name = "_" then
    name
  else
    pi.name + "." + name

let piRegEType (pi:PackageInfo) (tname:string) =
  let fullName = piFullName pi tname
  let etype = FExtType fullName
  etdPut pi.typeInfo tname fullName
  etype

// register function factory
let piRegFF (pi:PackageInfo) (fname:string) (ff:FuncFactory) (ps:ParseState) =
  ffdPut pi.funcInfo fname ff
  scRegisterVarFac ps.scope fname (GenFuncVar fname ff)
  ps

let regFF (pi:PackageInfo) (sc:Scope) (sff:string*FuncFactory) =
  let (ffname, ff) = sff
  let fullName = piFullName pi ffname 
  scRegisterVarFac sc fullName (GenFuncVar fullName ff)

let regET (sc:Scope) (etp:string*string) =
   let fullName = frt.Snd etp
   FExtType fullName
   |> scRegisterType sc fullName

/*
  PackageInfo = {name: string; funcInfo: funcFacDict; typeInfo: extTypeDict}
*/
let piRegAll (pi:PackageInfo) (sc:Scope) =
  ffdKVs pi.funcInfo
  |> slice.Iter (regFF pi sc)
  etdKVs pi.typeInfo
  |> slice.Iter (regET sc)

/*
  BinOp related
*/

type BinOpInfo = {precedence: int; goFuncName: string; isBoolOp: bool}

package_info _ =
  let lookupBinOp: TokenType->BinOpInfo*bool

/*
  '=' and '<>', we want to use DeepEqual isntead of go comparison.
  So it need special handling.
*/
let newEqNeq (tvgen: ()->TypeVar) (goFname:string) (lhs:Expr) (rhs:Expr) =
  let t1name = "T1"
  let t1tp = newTvf t1name
  let names =  [t1name]
  let tps = [t1tp; t1tp; FBool]
  let args = [lhs;rhs]
  genBuiltinFunCall tvgen goFname names tps args


let newPipeCallNormal (tvgen: ()->TypeVar) (lhs:Expr) (rhs:Expr) =  
  let t1name = "T1"
  let t1type = newTvf t1name
  let t2name = "T2"
  let t2type = newTvf t2name
  let secFncT = FFunc {FuncType.targets=[t1type;t2type]}
  let names =  [t1name; t2name]
  let tps = [t1type; secFncT; t2type]
  let args = [lhs;rhs]
  genBuiltinFunCall tvgen "frt.Pipe" names tps args

/*
frt.PipeUnit<T>: T->(T->())->()
*/
let newPipeCallUnit (tvgen: ()->TypeVar) (lhs:Expr) (rhs:Expr) =  
  let t1name = "T1"
  let t1type = newTvf t1name
  let secFncT = FFunc {FuncType.targets=[t1type;FUnit]}
  let names =  [t1name]
  let tps = [t1type; secFncT; FUnit]
  let args = [lhs;rhs]
  genBuiltinFunCall tvgen "frt.PipeUnit" names tps args


/*
frt.Pipe<T1, T2> : T1->(T1->T2)->T2

lhs |> rhs
rhs must be T1->T2 and we might resolve T1 or T2 by lhs T1 type.

If T2 is unit, use frt.PipeUnit instead.

*/
let newPipeCall (tvgen: ()->TypeVar) (lhs:Expr) (rhs:Expr) =  
  let rht = ExprToType rhs
  match rht with
  | FFunc ft ->
    match freturn ft with
    | FUnit -> newPipeCallUnit tvgen lhs rhs
    | _ -> newPipeCallNormal tvgen lhs rhs
  | _ -> newPipeCallNormal tvgen lhs rhs

// BinOpCall = {op: string; rtype: FType; lhs: Expr; rhs: Expr}
let newBinOpNormal (binfo:BinOpInfo) (lhs: Expr) (rhs:Expr) =
  let rtype = if binfo.isBoolOp then FBool else (ExprToType rhs)
  {op=binfo.goFuncName; rtype=rtype; lhs=lhs; rhs=rhs}
  |> EBinOpCall

let newBinOpCall (tvgen: ()->TypeVar) (tk:TokenType) (binfo: BinOpInfo) (lhs: Expr) (rhs:Expr) =
  match tk with
  | PIPE -> newPipeCall tvgen lhs rhs
  | EQ -> newEqNeq tvgen binfo.goFuncName lhs rhs
  | BRACKET -> newEqNeq tvgen binfo.goFuncName lhs rhs
  | _ -> newBinOpNormal binfo lhs rhs

let newFnTp (argType:FType) (retType:FType) =
  let tgs = [argType;retType]
  {FuncType.targets=tgs}
  |> FFunc

let emptySS () =
  GoEval<[]string> "[]string{}"

/*
  if else call.
*/
let newIfElseCall (tvgen: ()->TypeVar) (cond: Expr) (tbody: Block) (fbody: Block) =
  let ltbody = {LazyBlock.block=tbody} |> ELazyBlock
  let lfbody = {LazyBlock.block=fbody} |> ELazyBlock
  let retType = blockReturnType ExprToType tbody
  let fname = match retType with
              | FUnit -> "frt.IfElseUnit"
              | _ -> "frt.IfElse"
  let emptyS = emptySS ()
  let args = [cond; ltbody;lfbody]
  let ft = newFnTp FUnit retType
  let tps = [FBool; ft; ft; retType]
  genBuiltinFunCall tvgen fname emptyS tps args
  
let newIfOnlyCall (tvgen: ()->TypeVar) (cond: Expr) (tbody: Block) =
  let ltbody = {LazyBlock.block=tbody} |> ELazyBlock
  let emptyS = emptySS ()
  let args = [cond; ltbody]
  let ft = newFnTp FUnit FUnit
  let tps = [FBool; ft; ft; FUnit]
  genBuiltinFunCall tvgen "frt.IfOnly" emptyS tps args

let newUnaryNotCall (tvgen: ()->TypeVar) (cond: Expr) =
  let emptyS = emptySS ()
  let args = [cond]
  let tps = [FBool; FBool]
  genBuiltinFunCall tvgen "frt.OpNot" emptyS tps args
