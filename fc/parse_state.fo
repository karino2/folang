package main

import frt
import slice
import dict

/*
  GenFunc related
*/

// wrapper types.
package_info _ =
  type TypeDict
  let toTDict: []string*FType->TypeDict
  let tdLookup: TypeDict->string->FType*bool




/*
  TransformT FTypeVar and recomposite.
  FFieldAccess might be resolved.
*/
let transTypeVarFType (transTV: TypeVar->FType) (ftp:FType) : FType =
  let recurse = transTypeVarFType transTV
  match ftp with
  | FTypeVar tv -> transTV tv
  | FSlice ts ->
    let et = recurse ts.ElemType
    FSlice {SliceType.ElemType = et}
  | FTuple ftup ->
    let nts = slice.Map recurse ftup.ElemTypes
    {TupleType.ElemTypes=nts}
    |> FTuple
  | FFieldAccess fa ->
    let nrec = recurse fa.RecType
    {RecType=nrec; FieldName=fa.FieldName}
    |> faResolve
  | FFunc fnt ->
    let nts = slice.Map recurse fnt.Targets
    {FuncType.Targets=nts}
    |> FFunc
  | FParamd pt ->
    let nts = slice.Map recurse pt.Targs
    {Name=pt.Name; Targs=nts}
    |> FParamd
  | _ -> ftp

let transOneVar (transTV: TypeVar->FType) (v:Var) =
  let ntp = transTypeVarFType transTV v.Ftype
  {Var.Name=v.Name; Ftype=ntp}

let collectTVarFType (ft:FType) : []string =
  let recurse = collectTVarFType
  match ft with
  | FTypeVar tv -> [tv.Name]
  | FSlice ts ->
    recurse ts.ElemType
  | FTuple ftup ->
    slice.Collect recurse ftup.ElemTypes
  | FFieldAccess fa ->
    recurse fa.RecType
  | FFunc fnt ->
    slice.Collect recurse fnt.Targets
  | _ ->
    GoEval<[]string> "[]string{}"
  


let tpReplaceOne (tdic:TypeDict) (tv:TypeVar) =
  let (tp, ok) = tdLookup tdic tv.Name
  if ok then
    tp
  else
    FTypeVar tv

let tpreplace (tdic:TypeDict) (ft:FType) =
  transTypeVarFType (tpReplaceOne tdic) ft

let emptyFtps () =
  GoEval<[]FType> "[]FType{}"

let tpname2tvtp (tvgen: ()->TypeVar) (slist:[]FType) (i:int) (tpname:string) =
  if (slice.Len slist) > i then
    let item = slice.Item i slist
    (tpname, item)
  else
    let tv = tvgen () |> FTypeVar
    (tpname, tv)

let GenFunc (ff:FuncFactory) (stlist:[]FType) (tvgen: ()->TypeVar) =
  if (slice.Len stlist) > (slice.Len ff.Tparams) then
    frt.Panic "Too many type specified."
  let tdic = slice.Mapi (tpname2tvtp tvgen stlist) ff.Tparams |> toTDict
  let ntargets = slice.Map (tpreplace tdic) ff.Targets
  {FuncType.Targets=ntargets}

let GenFuncVar (vname:string) (ff:FuncFactory) (stlist: []FType) (tvgen: ()->TypeVar) =
  let funct = GenFunc ff stlist tvgen
  let ft = FFunc funct
  let v = {Var.Name=vname; Ftype=ft}
  if slice.IsEmpty stlist then
    VRVar v
  else
    VRSVar {SpecVar.Var = v; SpecList=stlist}

let genBuiltinFunCall (tvgen: ()->TypeVar) (fname:string) (tpnames: []string) (targetTPs:[]FType) (args:[]Expr) =
  let ff = {Tparams=tpnames; Targets=targetTPs}
  let fvar = GenFuncVar fname ff (emptyFtps ()) tvgen
  {TargetFunc=fvar; Args=args}
  |> EFunCall

let newTvf (name:string) =
   {TypeVar.Name=name}
   |> FTypeVar

/*
  TypeFactory related.
*/
let GenType (tfd:TypeFactoryData) (targs:[]FType) =
  if (slice.Len tfd.Tparams) <> (slice.Len targs) then
    frt.Panic "wrong type param num for instantiate."
  {Name=tfd.Name; Targs=targs}
  |> FParamd

/*
  Scope and Parser related
*/

// wrapper types.
package_info _ =
  type Scope
  let NewScope: ()->Scope
  let newScope: Scope->Scope
  let popScope: Scope->Scope
  let scDefVar: Scope->string->Var->()
  let scLookupVarFac: Scope->string->([]FType->(()->TypeVar)->VarRef)*bool
  let scRegisterRecType: Scope->RecordType->()
  let scLookupRecord: Scope->[]string->RecordType*bool
  let scLookupRecordByName: Scope->string->RecordType*bool
  let scRegisterType: Scope->string->FType->()
  let scRegisterTypeFac: Scope->string->([]FType->FType)->()
  let scRegisterVarFac: Scope->string->([]FType->(()->TypeVar)->VarRef)->()
  let scLookupTypeFac: Scope->string->([]FType->FType)*bool
  type TypeVarAllocator
  let NewTypeVarAllocator: string->TypeVarAllocator
  let tvaToTypeVarGen: TypeVarAllocator->(()->TypeVar)
  let tvaReset: TypeVarAllocator->()
  let resetUniqueTmpCounter: ()->()
  let tvaListAlloced: TypeVarAllocator->[]TypeVar
  let newTD: () -> TypeDict
  let tdPut: TypeDict->string->FType->()
  type EquivInfoDict
  let NewEquivInfoDict: ()->EquivInfoDict


type TypeDefCtx = {
  tva: TypeVarAllocator;
  insideTD: bool;
  defined: TypeDict;
  // key: tvname, value: fwrdDeclTypename
  allocedDict: dict.Dict<string, string>;
}

type Resolver = {eid: EquivInfoDict}

let newResolver () =
  let neid = NewEquivInfoDict ()
  {eid=neid}

type TypeVarCtx = {
  tva: TypeVarAllocator;
  resolver: Resolver;
}

let newTypeVarCtx () =
  let tva = NewTypeVarAllocator "_T"
  let res = newResolver ()
  {tva=tva; resolver=res}

let tvcToTypeVarGen (tvc:TypeVarCtx) =
  tvaToTypeVarGen tvc.tva

type ParseState = {
  tkz: Tokenizer;
  scope: Scope;
  offsideCol: []int;
  tvc: TypeVarCtx;
  tdctx: TypeDefCtx;
}


// wrapper types. Use ParseState
package_info _ =
  let withPs<T>: ParseState->T->ParseState*T
  // inference from funcall to arg side is NYI.
  // let CnvL<T, U>: (T->T)->T*U->T*U
  // let CnvR<T, U>: (U->U)->T*U->T*U
  let CnvL<U>: (ParseState->ParseState)->ParseState*U->ParseState*U
  let CnvR<T, U>: (T->U)->ParseState*T->ParseState*U


let newParse (tkz:Tokenizer) (scope:Scope) (offCols:[]int) (tvc:TypeVarCtx) (tdctx:TypeDefCtx) =
  {tkz=tkz; scope=scope; offsideCol=offCols; tvc=tvc; tdctx=tdctx}

let psWithTkz (org:ParseState) (tkz:Tokenizer) =
  newParse tkz org.scope org.offsideCol org.tvc org.tdctx

let psWithScope (org:ParseState) (nsc:Scope) =
  newParse org.tkz nsc org.offsideCol org.tvc org.tdctx

let psWithOffside (org:ParseState) (offs:[]int) =
  newParse org.tkz org.scope offs org.tvc org.tdctx

let psWithTDCtx (org:ParseState) (ntdctx:TypeDefCtx) =
  newParse org.tkz org.scope org.offsideCol org.tvc ntdctx

let psWithTVCtx (org:ParseState) (ntvctx:TypeVarCtx) =
  newParse org.tkz org.scope org.offsideCol ntvctx org.tdctx


let initParse (src: string) =
  let tkz = newTkz src
  let scope = NewScope ()
  let offside = [0]
  let tva2 = NewTypeVarAllocator "_P"
  let defdict = newTD ()
  let adict = dict.New<string, string> ()
  let tvctx = newTypeVarCtx ()
  let tdctx = {tva=tva2; insideTD=false; defined=defdict; allocedDict= adict}
  newParse tkz scope offside tvctx tdctx

let psSetNewSrc (src: string) (ps:ParseState) =
  let tkz = newTkz src
  psWithTkz ps tkz

let psTypeVarGen (ps:ParseState) =
  tvcToTypeVarGen ps.tvc

let psPushScope (org:ParseState) =
  newScope org.scope |> psWithScope org

let psPopScope (org:ParseState) =
  popScope org.scope |> psWithScope org

let psCurOffside (ps:ParseState) =
  slice.Last ps.offsideCol

let psCurCol (ps:ParseState) =
  ps.tkz.col

let psPushOffside (ps:ParseState) =
  let curCol = psCurCol ps
  if (psCurOffside ps) >= curCol then
    frt.Panic "Overrun offside rule"
  slice.PushLast curCol ps.offsideCol
  |> psWithOffside ps

let psPopOffside (ps:ParseState) =
  slice.PopLast ps.offsideCol
  |> psWithOffside ps

// reset defined dict and tva here.
let psEnterTypeDef (ps:ParseState) =
  let old = ps.tdctx
  let ntd = newTD ()
  let nald = dict.New<string, string> ()
  let ntdctx = {tva=old.tva; insideTD=true; defined=ntd; allocedDict=nald}
  tvaReset ntdctx.tva
  psWithTDCtx ps ntdctx

// stay defined dict and tva for further use.
let psLeaveTypeDef (ps:ParseState) =
  let old = ps.tdctx
  let ntdctx = {tva=old.tva; insideTD=false; defined=old.defined; allocedDict=old.allocedDict}
  psWithTDCtx ps ntdctx

let psInsideTypeDef (ps:ParseState) =
  ps.tdctx.insideTD

let tdctxTVFAlloc (tdctx:TypeDefCtx) (name:string) =
  let gen = tvaToTypeVarGen tdctx.tva
  let tvar = gen ()
  dict.Add tdctx.allocedDict tvar.Name name
  tvar |> FTypeVar


let psCurrent (ps:ParseState) =
  ps.tkz.current

let psCurrentTT (ps:ParseState) =
  let tk = psCurrent ps
  tk.ttype

let psCurIs (expectTT: TokenType) (ps:ParseState) =
  (psCurrentTT ps) = expectTT

let psNext (ps:ParseState) =
  let ntk = tkzNext ps.tkz
  psWithTkz ps ntk

let psNextTT (ps:ParseState) =
  psNext ps |> psCurrentTT

let psNextIs  (expectTT: TokenType) (ps:ParseState) =
  (psNextTT ps) = expectTT

let psNextNOL (ps:ParseState) =
  let ntk = tkzNextNOL ps.tkz
  psWithTkz ps ntk

let psSkipEOL (ps:ParseState) =
  if (psCurrentTT ps) = EOL then
    psNextNOL ps
  else
    ps


let psExpect (ttype:TokenType) (ps:ParseState) =
  let cur = psCurrent ps
  if cur.ttype <> ttype then
    frt.Panic("non expected token")
  ()

let psConsume (ttype:TokenType) (ps:ParseState) =
  psExpect ttype ps
  psNext ps


let psIdentName (ps:ParseState) =
  psExpect IDENTIFIER ps
  let cur = psCurrent ps
  cur.stringVal

let psStringVal (ps:ParseState) =
  psExpect STRING ps
  let cur = psCurrent ps
  cur.stringVal

let psStrNx (f: ParseState->string) (ps:ParseState) =
  let s = f ps
  let ps2 = psNext ps
  (ps2, s)


// psIdentName and Next
let psIdentNameNx (ps:ParseState) =
  psStrNx psIdentName ps

let psStringValNx (ps:ParseState) =
  psStrNx psStringVal ps


let psCurrentNx (ps:ParseState) =
  let tk = psCurrent ps
  let ps2 = psNext ps
  (ps2, tk)

let psCurrentTTNx (ps:ParseState) =
  let tt = psCurrentTT ps
  let ps2 = psNext ps
  (ps2, tt)

// NxL means NextNOL
let psIdentNameNxL (ps:ParseState) =
  psIdentNameNx ps |> CnvL psSkipEOL

let psStringValNxL (ps:ParseState) =
  psStringValNx ps |> CnvL psSkipEOL

let psCurrentNxL (ps:ParseState) =
  psCurrentNx ps |> CnvL psSkipEOL

let psCurrentTTNxL (ps:ParseState) =
  psCurrentTTNx ps |> CnvL psSkipEOL

let psResetTmpCtx (ps:ParseState) =
  resetUniqueTmpCounter ()
  newTypeVarCtx ()
  |> psWithTVCtx ps


let psIsNeighborLT (ps:ParseState) =
   tkzIsNeighborLT ps.tkz

/*
UnionDef related utility.
*/

let udToUt (ud:UnionDef) =
  GoEval<UnionType> "UnionType(ud)"

let udToFUt (ud:UnionDef) =
  udToUt ud |> FUnion

/*
// New_IntOrString_I
let csConstructorName  (unionName: string) (cas: NameTypePair) =
*/
let csRegisterCtor (sc:Scope) (ud: UnionDef) (cas: NameTypePair) =
  let ctorName = csConstructorName ud.Name cas
  let ut = udToFUt ud
  let v = match cas.Ftype with
          | FUnit ->
            {Var.Name=ctorName; Ftype=ut}
          | _ ->
            let tps = [cas.Ftype; ut]
            let funcTp = FFunc {Targets=tps}
            {Var.Name=ctorName; Ftype=funcTp}
  scDefVar sc cas.Name v

let udRegisterCsCtors (sc:Scope) (ud:UnionDef) =
  ud.Cases |> slice.Iter (csRegisterCtor sc ud)


/*
PackageInfo related utility.
*/

package_info _ =
  let ffdPut: funcFacDict->string->FuncFactory->()
  let ffdKVs: funcFacDict->[]string*FuncFactory
  let tfddPut: TFDataDict->string->TypeFactoryData->()
  let tfddKVs: TFDataDict->[]string*TypeFactoryData

let piFullName (pi:PackageInfo) (name:string) =
  if pi.Name = "_" then
    name
  else
    pi.Name + "." + name

let piRegEType (pi:PackageInfo) (tname:string) (tparams:[]string) =
  let fullName = piFullName pi tname
  let tfd = {Name=fullName; Tparams=tparams}
  tfddPut pi.TypeInfo tname tfd
  tfd

let scRegFunFac (sc:Scope) (fname:string) (ff:FuncFactory) =
  scRegisterVarFac sc fname (GenFuncVar fname ff)


let scRegTFData (sc:Scope) (tname:string) (tfd:TypeFactoryData) =
  scRegisterTypeFac sc tname (GenType tfd)


// register function factory
let piRegFF (pi:PackageInfo) (fname:string) (ff:FuncFactory) (ps:ParseState) =
  ffdPut pi.FuncInfo fname ff
  scRegFunFac ps.scope fname ff
  ps

let regFF (pi:PackageInfo) (sc:Scope) (sff:string*FuncFactory) =
  let (ffname, ff) = sff
  let fullName = piFullName pi ffname 
  scRegFunFac sc fullName ff

let regTF  (pi:PackageInfo) (sc:Scope) (etp:string*TypeFactoryData) =
  let tfd = frt.Snd etp
  scRegTFData sc tfd.Name tfd

/*
  PackageInfo = {name: string; funcInfo: funcFacDict; typeInfo: TFDataDict}
*/
let piRegAll (pi:PackageInfo) (sc:Scope) =
  ffdKVs pi.FuncInfo
  |> slice.Iter (regFF pi sc)
  tfddKVs pi.TypeInfo
  |> slice.Iter (regTF pi sc)

/*
  BinOp related
*/

type BinOpInfo = {Precedence: int; GoFuncName: string; IsBoolOp: bool}

package_info _ =
  let lookupBinOp: TokenType->BinOpInfo*bool

/*
  '=' and '<>', we want to use DeepEqual isntead of go comparison.
  So it need special handling.
*/
let newEqNeq (tvgen: ()->TypeVar) (goFname:string) (lhs:Expr) (rhs:Expr) =
  let t1name = "T1"
  let t1tp = newTvf t1name
  let names =  [t1name]
  let tps = [t1tp; t1tp; FBool]
  let args = [lhs;rhs]
  genBuiltinFunCall tvgen goFname names tps args


let newPipeCallNormal (tvgen: ()->TypeVar) (lhs:Expr) (rhs:Expr) =  
  let t1name = "T1"
  let t1type = newTvf t1name
  let t2name = "T2"
  let t2type = newTvf t2name
  let secFncT = FFunc {FuncType.Targets=[t1type;t2type]}
  let names =  [t1name; t2name]
  let tps = [t1type; secFncT; t2type]
  let args = [lhs;rhs]
  genBuiltinFunCall tvgen "frt.Pipe" names tps args

/*
frt.PipeUnit<T>: T->(T->())->()
*/
let newPipeCallUnit (tvgen: ()->TypeVar) (lhs:Expr) (rhs:Expr) =  
  let t1name = "T1"
  let t1type = newTvf t1name
  let secFncT = FFunc {FuncType.Targets=[t1type;FUnit]}
  let names =  [t1name]
  let tps = [t1type; secFncT; FUnit]
  let args = [lhs;rhs]
  genBuiltinFunCall tvgen "frt.PipeUnit" names tps args


/*
frt.Pipe<T1, T2> : T1->(T1->T2)->T2

lhs |> rhs
rhs must be T1->T2 and we might resolve T1 or T2 by lhs T1 type.

If T2 is unit, use frt.PipeUnit instead.

*/
let newPipeCall (tvgen: ()->TypeVar) (lhs:Expr) (rhs:Expr) =  
  let rht = ExprToType rhs
  match rht with
  | FFunc ft ->
    match freturn ft with
    | FUnit -> newPipeCallUnit tvgen lhs rhs
    | _ -> newPipeCallNormal tvgen lhs rhs
  | _ -> newPipeCallNormal tvgen lhs rhs

// BinOpCall = {op: string; rtype: FType; lhs: Expr; rhs: Expr}
let newBinOpNormal (binfo:BinOpInfo) (lhs: Expr) (rhs:Expr) =
  let rtype = if binfo.IsBoolOp then FBool else (ExprToType rhs)
  {Op=binfo.GoFuncName; Rtype=rtype; Lhs=lhs; Rhs=rhs}
  |> EBinOpCall

let newBinOpCall (tvgen: ()->TypeVar) (tk:TokenType) (binfo: BinOpInfo) (lhs: Expr) (rhs:Expr) =
  match tk with
  | PIPE -> newPipeCall tvgen lhs rhs
  | EQ -> newEqNeq tvgen binfo.GoFuncName lhs rhs
  | BRACKET -> newEqNeq tvgen binfo.GoFuncName lhs rhs
  | _ -> newBinOpNormal binfo lhs rhs

let newFnTp (argType:FType) (retType:FType) =
  let tgs = [argType;retType]
  {FuncType.Targets=tgs}
  |> FFunc

let emptySS () =
  GoEval<[]string> "[]string{}"

/*
  if else call.
*/
let newIfElseCall (tvgen: ()->TypeVar) (cond: Expr) (tbody: Block) (fbody: Block) =
  let ltbody = {LazyBlock.Block=tbody} |> ELazyBlock
  let lfbody = {LazyBlock.Block=fbody} |> ELazyBlock
  let retType = blockReturnType ExprToType tbody
  let fname = match retType with
              | FUnit -> "frt.IfElseUnit"
              | _ -> "frt.IfElse"
  let emptyS = emptySS ()
  let args = [cond; ltbody;lfbody]
  let ft = newFnTp FUnit retType
  let tps = [FBool; ft; ft; retType]
  genBuiltinFunCall tvgen fname emptyS tps args
  
let newIfOnlyCall (tvgen: ()->TypeVar) (cond: Expr) (tbody: Block) =
  let ltbody = {LazyBlock.Block=tbody} |> ELazyBlock
  let emptyS = emptySS ()
  let args = [cond; ltbody]
  let ft = newFnTp FUnit FUnit
  let tps = [FBool; ft; FUnit]
  genBuiltinFunCall tvgen "frt.IfOnly" emptyS tps args

let newUnaryNotCall (tvgen: ()->TypeVar) (cond: Expr) =
  let emptyS = emptySS ()
  let args = [cond]
  let tps = [FBool; FBool]
  genBuiltinFunCall tvgen "frt.OpNot" emptyS tps args

/*
  TypeDef related.
  Register type info to TypeDefCtx, etc.
*/

let rdToRecType (rd:RecordDef) =
  // golang complaint:
  // S1016 - Use a type conversion instead of manually copying struct fields 
  // {RecordType.Name=rd.Name; Fields=rd.Fields}
  GoEval<RecordType> "RecordType(rd)"

let psRegRecDefToTDCtx (rd:RecordDef) (ps:ParseState) =
  let recT = rdToRecType rd
  scRegisterRecType ps.scope recT
  tdPut ps.tdctx.defined recT.Name (FRecord recT)

let psRegUdToTDCtx (ud:UnionDef) (ps:ParseState) =
  let sc = ps.scope
  udRegisterCsCtors sc ud
  let fut = udToFUt ud
  scRegisterType sc ud.Name fut
  tdPut ps.tdctx.defined ud.Name fut

/*
  MultipleDefs resolve forward declaration, etc.
*/
let transVNTPair (transV: TypeVar->FType) (ntp:NameTypePair) =
  let nt = transTypeVarFType transV ntp.Ftype
  {NameTypePair.Name=ntp.Name; Ftype=nt}

let transDefStmt (transV: TypeVar->FType) (df: DefStmt) =
  match df with
  | DRecordDef rd ->
    let nfields = slice.Map (transVNTPair transV) rd.Fields
    {RecordDef.Name=rd.Name; Fields=nfields}
    |> DRecordDef
  | DUnionDef ud ->
    let ncases = slice.Map (transVNTPair transV) ud.Cases
    {UnionDef.Name=ud.Name; Cases=ncases}
    |> DUnionDef

let transVByTDCtx (tdctx:TypeDefCtx) (tv:TypeVar) =
  let (rname, ok) = dict.TryFind tdctx.allocedDict tv.Name
  if ok then
    let (nt, ok2) = tdLookup tdctx.defined rname
    if ok2 then
      nt
    else
      frt.Panic "Unresolved foward decl type"
      nt
  else
    FTypeVar tv

let resolveFwrdDecl (md:MultipleDefs) (ps:ParseState) =
  let transV = transVByTDCtx ps.tdctx
  let transD = transDefStmt transV
  let ndefs = slice.Map transD md.Defs
  {Defs=ndefs}

let scRegDefStmtType (sc:Scope) (df: DefStmt) =
  match df with
  | DRecordDef rd ->
    rdToRecType rd
    |>  scRegisterRecType sc
  | DUnionDef ud ->
    udRegisterCsCtors sc ud
    let fut = udToFUt ud
    scRegisterType sc ud.Name fut


let psRegMdTypes (md:MultipleDefs) (ps:ParseState) =
  slice.Iter (scRegDefStmtType ps.scope) md.Defs

