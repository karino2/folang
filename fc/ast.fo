package main

// wrapper types.
package_info _ =
  type funcTypeDict
  type extTypeDict

type GoEvalExpr = {goStmt: string; typeArg: FType}
type Var = {name: string; ftype: FType}

// stands for record field access of form: targetName.fieldName
type FieldAccess = {targetName: string; targetType: RecordType; fieldName: string}

/*
Union case matching.
Only support variable match for a while:
| I i -> ...
| Record r -> ...
*/
type MatchPattern = {caseId: string; varName: string}

type Expr =
| EGoEvalExpr of GoEvalExpr
| EStringLiteral of string
| EIntImm of int
| EUnit
| EBoolLiteral of bool
| EFunCall of FunCall
| EFieldAccess of FieldAccess
| EVar of Var
| ESlice of []Expr
| ERecordGen of RecordGen
| ELazyBlock of LazyBlock
/*
  For some expr, normally we need to wrap with func() to become expr in go stmt
  But in some case like final expr of block, just return is enough and do not need to wrap func().
  We use type ReturnableExpr for expr of which we can emit directlry return go code.
*/
| EReturnableExpr of ReturnableExpr
and FunCall = {targetFunc: Var; args: []Expr}
and NEPair = {name: string; expr: Expr}
and RecordGen = {fieldsNV: []NEPair; recordType: RecordType}
and Block = {stmts: []Stmt; finalExpr: Expr}
and LazyBlock = {stmts: []Stmt; finalExpr: Expr}
and MatchRule = {pattern: MatchPattern; body: Block}
and MatchExpr = {target: Expr; rules: []MatchRule}
and ReturnableExpr =
| RBlock of Block
| RMatchExpr of MatchExpr
and Stmt =
| SImport of string
| SPackage of string
| SPackageInfo of PackageInfo
| SLetFuncDef of LetFuncDef
| SLetVarDef of LetVarDef
| SExprStmt of Expr
| SDefStmt of DefStmt
| SMultipleDefs of MultipleDefs
and LetFuncDef = {name: string; params: []Var; body:Block}
and LetVarDef = {name: string; rhs: Expr}
and PackageInfo = {name: string; funcInfo: funcTypeDict; typeInfo: extTypeDict}
and RecordDef = {name: string; fields: []NameTypePair}
and UnionDef = {name: string; cases: []NameTypePair}
and DefStmt =
| DRecordDef of RecordDef
| DUnionDef of UnionDef
and MultipleDefs = {defs: []DefStmt}

