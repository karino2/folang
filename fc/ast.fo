package main

// wrapper types.
package_info _ =
  type funcTypeDict
  type extTypeDict
  let newFTD: ()->funcTypeDict
  let newETD: ()->extTypeDict
  let ftdPut: funcTypeDict->string->FuncType->()
  let etdPut: extTypeDict->string->string->()
  let ftdKVs: funcTypeDict->[]string*FuncType
  let etdKVs: extTypeDict->[]string*string
  let uniqueTmpVarName: ()->string

type GoEval = {goStmt: string; typeArg: FType}
type Var = {name: string; ftype: FType}

// stands for record field access of form: targetName.fieldName
type FieldAccess = {targetName: string; targetType: RecordType; fieldName: string}

/*
Union case matching.
Only support variable match for a while:
| I i -> ...
| Record r -> ...
*/
type MatchPattern = {caseId: string; varName: string}

type Expr =
| GoEval of GoEval
| StringLiteral of string
| IntImm of int
| Unit
| BoolLiteral of bool
| FunCall of FunCall
| FieldAccess of FieldAccess
| Var of Var
| RecordGen of RecordGen
| LazyBlock of LazyBlock
/*
  For some expr, normally we need to wrap with func() to become expr in go stmt
  But in some case like final expr of block, just return is enough and do not need to wrap func().
  We use type ReturnableExpr for expr of which we can emit directlry return go code.
*/
| ReturnableExpr of ReturnableExpr
and FunCall = {targetFunc: Var; args: []Expr}
and RecordGen = {fieldNames: []string; fieldValues: []Expr; recordType: RecordType}
and Block = {stmts: []Stmt; finalExpr: Expr}
and LazyBlock = {stmts: []Stmt; finalExpr: Expr}
and MatchRule = {pattern: MatchPattern; body: Block}
and MatchExpr = {target: Expr; rules: []MatchRule}
and ReturnableExpr =
| Block of Block
| MatchExpr of MatchExpr
and Stmt =
| Import of string
| Package of string
| PackageInfo of PackageInfo
| LetFuncDef of LetFuncDef
| LetVarDef of LetVarDef
| ExprStmt of Expr
| DefStmt of DefStmt
| MultipleDefs of MultipleDefs
and LetFuncDef = {name: string; params: []Var; body:Block}
and LetVarDef = {name: string; rhs: Expr}
and PackageInfo = {name: string; funcInfo: funcTypeDict; typeInfo: extTypeDict}
and RecordDef = {name: string; fields: []NameTypePair}
and UnionDef = {name: string; cases: []NameTypePair}
and DefStmt =
| RecordDef of RecordDef
| UnionDef of UnionDef
and MultipleDefs = {defs: []DefStmt}

