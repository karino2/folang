package main

import frt
import slice
import buf
import strings

// wrapper types.
package_info _ =
  type funcTypeDict
  type extTypeDict
  let newFTD: ()->funcTypeDict
  let newETD: ()->extTypeDict
  let ftdPut: funcTypeDict->string->FuncType->()
  let etdPut: extTypeDict->string->string->()
  let ftdKVs: funcTypeDict->[]string*FuncType
  let etdKVs: extTypeDict->[]string*string
  let uniqueTmpVarName: ()->string



type GoEval = {goStmt: string; typeArg: FType}
type Var = {name: string; ftype: FType}

// stands for record field access of form: targetName.fieldName
type FieldAccess = {targetName: string; targetType: RecordType; fieldName: string}

/*
Union case matching.
Only support variable match for a while:
| I i -> ...
| Record r -> ...
*/
type MatchPattern = {caseId: string; varName: string}

type Expr =
| GoEval of GoEval
| StringLiteral of string
| IntImm of int
| Unit
| BoolLiteral of bool
| FunCall of FunCall
| FieldAccess of FieldAccess
| Var of Var
| RecordGen of RecordGen
| LazyBlock of LazyBlock
/*
  For some expr, normally we need to wrap with func() to become expr in go stmt
  But in some case like final expr of block, just return is enough and do not need to wrap func().
  We use type ReturnableExpr for expr of which we can emit directlry return go code.
*/
| ReturnableExpr of ReturnableExpr
and FunCall = {targetFunc: Var; args: []Expr}
and RecordGen = {fieldNames: []string; fieldValues: []Expr; recordType: RecordType}
and Block = {stmts: []Stmt; finalExpr: Expr}
and LazyBlock = {stmts: []Stmt; finalExpr: Expr}
and MatchRule = {pattern: MatchPattern; body: Block}
and MatchExpr = {target: Expr; rules: []MatchRule}
and ReturnableExpr =
| Block of Block
| MatchExpr of MatchExpr
and Stmt =
| Import of string
| Package of string
| PackageInfo of PackageInfo
| LetFuncDef of LetFuncDef
| LetVarDef of LetVarDef
| ExprStmt of Expr
| DefStmt of DefStmt
| MultipleDefs of MultipeDefs
and LetFuncDef = {name: string; params: []Var; body:Block}
and LetVarDef = {name: string; rhs: Expr}
and PackageInfo = {name: string; funcInfo: funcTypeDict; typeInfo: extTypeDict}
and RecordDef = {name: string; fields: []NameTypePair}
and UnionDef = {name: string; cases: []NameTypePair}
and DefStmt =
| RecordDef of RecordDef
| UnionDef of UnionDef
and MultipeDefs = {defs: []DefStmt}

let faToType (fa:FieldAccess) =
  let rt = fa.targetType
  let field = frGetField rt fa.fieldName
  field.ftype


let lblockReturnType (toT: Expr->FType) (lb:LazyBlock) =
  toT lb.finalExpr

let lblockToType (toT: Expr->FType)  (lb:LazyBlock)=
  let rtype = lblockReturnType toT lb
  FFunc {targets=[FUnit; rtype]}

let blockReturnType (toT: Expr->FType) (block:Block) =
  toT block.finalExpr

let blockToType (toT: Expr->FType)  (b:Block)=
  blockReturnType toT b

let blockToExpr (block:Block) =
  ReturnableExpr (Block block)

let meToType (toT: Expr->FType) (me:MatchExpr) =
  let frule = me.rules |> slice.Head
  frule.body |> blockToExpr |> toT

let returnableToType (toT: Expr->FType) (rexpr:ReturnableExpr)  : FType =
  match rexpr with
  | Block b -> blockToType toT b
  | MatchExpr me -> meToType toT me

let fcToFuncType (fc:FunCall) =
  // double field access like fc.targetFunc.ftype is NYI.
  let tfv = fc.targetFunc
  let ft = tfv.ftype
  match ft with
  | FFunc ft -> ft
  | _ -> GoEval<FuncType> "FuncType{}" // never happens.

let fcArgTypes (fc:FunCall) =
  fcToFuncType fc |> fargs

let fcToType (fc:FunCall) =
  let ft = fcToFuncType fc
  let tlen = fargs ft |> slice.Length
  let alen = slice.Length fc.args
  if alen = tlen then
    freturn ft
  else
    // prtial apply.
    GoEval "if alen > tlen { panic(\"too many arugments\")}"
    let newts = slice.Skip alen ft.targets
    FFunc {targets=newts}

let ExprToType (expr:Expr) : FType =
  match expr with
  | GoEval ge -> ge.typeArg
  | StringLiteral _ -> FString
  | IntImm _ -> FInt
  | Unit -> FUnit
  | BoolLiteral _ -> FBool
  | FieldAccess fa -> faToType fa
  | Var v -> v.ftype
  | RecordGen rg -> FRecord rg.recordType
  | LazyBlock lb -> lblockToType ExprToType lb
  | ReturnableExpr re -> returnableToType ExprToType re
  | FunCall fc -> fcToType fc

let rgFVToGo  (toGo: Expr->string) (fvPair: string*Expr) =
  let fn = frt.Fst fvPair
  let fv = frt.Snd fvPair
  let fvGo = toGo fv
  fn + ": " + fvGo

let rgToGo (toGo: Expr->string) (rg:RecordGen) =
  let rtype = rg.recordType
  let b = buf.New ()
  frStructName rtype |> buf.Write b
  buf.Write b "{"
  let fvGo = slice.Zip rg.fieldNames rg.fieldValues
             |> slice.Map (rgFVToGo toGo)
             |> strings.Concat ", "
  buf.Write b fvGo
  buf.Write b "}"
  buf.String b

/*

  blockToGo implementation.

*/

/*
  []Stmt+Expr -> []GoStmt+ return Expr.
*/
let buildReturn (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (stmts:[]Stmt) (lastExpr: Expr) =
  let stmtGos = slice.Map sToGo stmts |> strings.Concat "\n"
  let lastGo = match lastExpr with
              | ReturnableExpr re -> reToGoRet re
              | _ ->
                let mayReturn = if ExprToType lastExpr = FUnit then "" else "return "
                let lg = eToGo lastExpr
                mayReturn + lg
  stmtGos + "\n" + lastGo


let wrapFunc (toGo: FType->string) (rtype:FType) (goReturnBody:string) =
  let b = buf.New ()
  buf.Write b "(func () "
  toGo rtype |> buf.Write b
  buf.Write b " {\n"
  buf.Write b goReturnBody
  buf.Write b"})"
  buf.String b

let wrapFunCall (toGo: FType->string) (rtype:FType) (goReturnBody:string) =
  let wf = wrapFunc toGo rtype goReturnBody
  wf + "()"

let lbToGo (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (lb:LazyBlock) =
  let returnBody = buildReturn sToGo eToGo reToGoRet lb.stmts lb.finalExpr
  let rtype = ExprToType lb.finalExpr
  wrapFunc FTypeToGo rtype returnBody

let blockToGoReturn (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (block:Block) =
  buildReturn sToGo eToGo reToGoRet block.stmts block.finalExpr

let blockToGo (sToGo: Stmt->string) (eToGo: Expr->string) (reToGoRet: ReturnableExpr->string) (block:Block) =
  let goRet = blockToGoReturn sToGo eToGo reToGoRet block
  let rtype = ExprToType block.finalExpr
  wrapFunCall FTypeToGo rtype goRet 

/*

  MatchExprToGo implementation

*/

/*
Build following case header. (If unit or _ variable, generate code appropriately.)

  case IntOrBool_I:
    [varName] := tmpV
*/
let mpToCaseHeader (uname: string) (mp: MatchPattern) (tmpVarName: string) =
  let b = buf.New ()
  buf.Write b "case "
  unionCaseStructName uname mp.caseId |> buf.Write b
  buf.Write b ":\n"
  if mp.varName <> "_" && mp.varName <> "" then
    buf.Write b mp.varName
    buf.Write b " := "
    buf.Write b tmpVarName
    buf.Write b ".Value"
    buf.Write b "\n"
  buf.String b

/*
 btogRet is bounded blockToGoReturn.

 Generate following codes.)

case IntOrBool_I:
	[varName] := tmpV
	body...

or

default:
   body...

*/
let mrToCase (btogRet: Block->string) (uname: string) (tmpVarName: string) (mr: MatchRule)  =
  let b = buf.New ()
  let mp = mr.pattern
  let cheader = if mp.caseId = "_" then
                  "default:\n"
                else
                  mpToCaseHeader uname mp tmpVarName
  buf.Write b cheader
  btogRet mr.body |> buf.Write b
  buf.Write b "\n"
  buf.String b  

let mrHasCaseVar (mr: MatchRule) =
  let pat = mr.pattern
  pat.caseId <> "_" && pat.varName <> "" && pat.varName <> "_"

/*
  If atlease one value or not (if not, tmp var is not necessary).
*/
let meHasCaseVar (me:MatchExpr) =
  slice.Forall mrHasCaseVar me.rules

let mrIsDefault (mr:MatchRule) =
  let pat = mr.pattern
  pat.caseId = "_"


let meToGoReturn (toGo: Expr->string) (btogRet: Block->string) (me:MatchExpr) =
  let ttype = ExprToType me.target
  let uttype = GoEval<UnionType> "ttype.(FType_FUnion).Value" // for non UnionType, NYI.
  let hasCaseVar = meHasCaseVar me
  let hasDefault = slice.Forany mrIsDefault me.rules
  let tmpVarName = if hasCaseVar then uniqueTmpVarName () else ""
  let mrtocase = mrToCase btogRet uttype.name tmpVarName
  let b = buf.New ()
  buf.Write b "switch "
  if hasCaseVar then
    buf.Write b tmpVarName
    buf.Write b " := "
  buf.Write b "("
  toGo me.target |> buf.Write b 
  buf.Write b ").(type){\n"
  slice.Map mrtocase me.rules
   |> strings.Concat ""
   |> buf.Write b
  if not hasDefault then
     buf.Write b "default:\npanic(\"Union pattern fail. Never reached here.\")\n"
  buf.Write b "}"
  buf.String b

let meToExpr (me:MatchExpr) =
  MatchExpr me |> ReturnableExpr

let meToGo (toGo: Expr->string) (btogRet: Block->string) (me:MatchExpr) =
  let goret = meToGoReturn toGo btogRet me
  let rtype = ExprToType (meToExpr me)
  wrapFunCall FTypeToGo rtype goret

let reToGoReturn (sToGo: Stmt->string) (eToGo: Expr->string) (rexpr:ReturnableExpr) : string=
  let rtgr = reToGoReturn sToGo eToGo
  let btogoRet = blockToGoReturn sToGo eToGo rtgr
  match rexpr with
  | Block b -> blockToGoReturn sToGo eToGo rtgr b
  | MatchExpr me -> meToGoReturn eToGo btogoRet me

let reToGo (sToGo: Stmt->string) (eToGo: Expr->string) (rexpr:ReturnableExpr) : string=
  let rtgr = reToGoReturn sToGo eToGo
  let btogRet = blockToGoReturn sToGo eToGo rtgr
  match rexpr with
  | Block b -> blockToGo sToGo eToGo rtgr b
  | MatchExpr me -> meToGo eToGo btogRet me

let ExprToGo (sToGo: Stmt->string) (expr:Expr) : string =
  let eToGo = ExprToGo sToGo
  match expr with
  | BoolLiteral b -> frt.Sprintf1 "%t" b
  | GoEval ge -> ge.goStmt
  | StringLiteral s -> frt.Sprintf1 "\\\"%s\\\"" s
  | IntImm i -> frt.Sprintf1 "%d" i
  | Unit -> ""
  | FieldAccess fa -> fa.targetName + "." + fa.fieldName
  | Var v -> v.name
  | RecordGen rg -> rgToGo eToGo rg
  | ReturnableExpr re -> reToGo sToGo eToGo re
  | FunCall _ -> "NYI"

