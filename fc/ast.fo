package main

import frt
import slice
import buf
import strings

type GoEval = {goStmt: string; typeArg: FType}
type Var = {name: string; ftype: FType}

// stands for record field access of form: targetName.fieldName
type FieldAccess = {targetName: string; targetType: RecordType; fieldName: string}

/*
Union case matching.
Only support variable match for a while:
| I i -> ...
| Record r -> ...
*/
type MatchPattern = {caseId: string; varName: string}

type Expr =
| GoEval of GoEval
| StringLiteral of string
| IntImm of int
| Unit
| BoolLiteral of bool
| FunCall of FunCall
| FieldAccess of FieldAccess
| Var of Var
| RecordGen of RecordGen
/*
  For some expr, normally we need to wrap with func() to become expr in go stmt
  But in some case like final expr of block, just return is enough and do not need to wrap func().
  We use type ReturnableExpr for expr of which we can emit directlry return go code.
*/
| ReturnableExpr of ReturnableExpr
and FunCall = {targetFunc: Var; args: []Expr}
and RecordGen = {fieldNames: []string; fieldValues: []Expr; recordType: RecordType}
and Block = {stms: []Stmt; finalExpr: Expr; asFunc: bool}
and MatchRule = {pattern: MatchPattern; body: Block}
and MatchExpr = {target: Expr; rules: []MatchRule}
and ReturnableExpr =
| Block of Block
| MatchExpr of MatchExpr
and Stmt =
| Import of string
| Package of string
| LetFuncDef of LetFuncDef
| LetVarDef of LetVarDef
| ExprStmt of Expr
| DefStmt of DefStmt
| MultipleDefs of MultipeDefs
and LetFuncDef = {name: string; params: []Var; body:Block}
and LetVarDef = {name: string; rhs: Expr}
and RecordDef = {name: string; fields: []NameTypePair}
and UnionDef = {name: string; cases: []NameTypePair}
and DefStmt =
| RecordDef of RecordDef
| UnionDef of UnionDef
and MultipeDefs = {defs: []DefStmt}


/*
map, NYI
and PackageInfo = {name: string; funcInfo: map<string, FuncType>; typeInfo: map<string, FExtType>}

| PackageInfo of PackageInfo
*/

let faToType (fa:FieldAccess) =
  let rt = fa.targetType
  let field = frGetField rt fa.fieldName
  field.ftype

let blockReturnType (toT: Expr->FType) (block:Block) =
  toT block.finalExpr

let blockToType (toT: Expr->FType)  (b:Block)=
  let rtype = blockReturnType toT b
  if b.asFunc then
    FFunc {targets=[FUnit; rtype]}
  else
    rtype

let blockToExpr (block:Block) =
  ReturnableExpr (Block block)

let meToType (toT: Expr->FType) (me:MatchExpr) =
  let frule = me.rules |> slice.Head
  frule.body |> blockToExpr |> toT

let returnableToType (toT: Expr->FType) (rexpr:ReturnableExpr)  : FType =
  match rexpr with
  | Block b -> blockToType toT b
  | MatchExpr me -> meToType toT me

let fcToFuncType (fc:FunCall) =
  // double field access like fc.targetFunc.ftype is NYI.
  let tfv = fc.targetFunc
  let ft = tfv.ftype
  match ft with
  | FFunc ft -> ft
  | _ -> GoEval<FuncType> "FuncType{}" // never happens.

let fcArgTypes (fc:FunCall) =
  fcToFuncType fc |> fargs

let fcToType (fc:FunCall) =
  let ft = fcToFuncType fc
  let tlen = fargs ft |> slice.Length
  let alen = slice.Length fc.args
  if alen = tlen then
    freturn ft
  else
    // prtial apply.
    GoEval "if alen > tlen { panic(\"too many arugments\")}"
    let newts = slice.Skip alen ft.targets
    FFunc {targets=newts}

let ExprToType (expr:Expr) : FType =
  match expr with
  | GoEval ge -> ge.typeArg
  | StringLiteral _ -> FString
  | IntImm _ -> FInt
  | Unit -> FUnit
  | BoolLiteral _ -> FBool
  | FieldAccess fa -> faToType fa
  | Var v -> v.ftype
  | RecordGen rg -> FRecord rg.recordType
  | ReturnableExpr re -> returnableToType ExprToType re
  | FunCall fc -> fcToType fc

let rgFVToGo  (toGo: Expr->string) (fvPair: string*Expr) =
  let fn = frt.Fst fvPair
  let fv = frt.Snd fvPair
  let fvGo = toGo fv
  fn + ": " + fvGo

let rgToGo (toGo: Expr->string) (rg:RecordGen) =
  let rtype = rg.recordType
  let b = buf.New ()
  frStructName rtype |> buf.Write b
  buf.Write b "{"
  let fvGo = slice.Zip rg.fieldNames rg.fieldValues
             |> slice.Map (rgFVToGo toGo)
             |> strings.Concat ", "
  buf.Write b fvGo
  buf.Write b "}"
  buf.String b


let ExprToGo (expr:Expr) : string =
  match expr with
  | BoolLiteral b -> frt.Sprintf1 "%t" b
  | GoEval ge -> ge.goStmt
  | StringLiteral s -> frt.Sprintf1 "\\\"%s\\\"" s
  | IntImm i -> frt.Sprintf1 "%d" i
  | Unit -> ""
  | FieldAccess fa -> fa.targetName + "." + fa.fieldName
  | Var v -> v.name
  | RecordGen rg -> rgToGo ExprToGo rg
  | ReturnableExpr _ -> "NYI"
  | FunCall _ -> "NYI"

