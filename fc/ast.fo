package main

// wrapper types.
package_info _ =
  type funcFacDict
  type extTypeDict
  let newFFD: ()->funcFacDict
  let newETD: ()->extTypeDict

type GoEvalExpr = {goStmt: string; typeArg: FType}
type Var = {name: string; ftype: FType}

// stands for record field access of form: targetName.fieldName
type FieldAccess = {targetName: string; targetType: RecordType; fieldName: string}

/*
Union case matching.
Only support variable match for a while:
| I i -> ...
| Record r -> ...
*/
type MatchPattern = {caseId: string; varName: string}

// external package func info.
type FuncFactory = {tparams:[]string; targets:[]FType}

type Expr =
| EGoEvalExpr of GoEvalExpr
| EStringLiteral of string
| EIntImm of int
| EUnit
| EBoolLiteral of bool
| EFunCall of FunCall
| EFieldAccess of FieldAccess
| EVar of Var
| ESlice of []Expr
| ERecordGen of RecordGen
| ELazyBlock of LazyBlock
/*
  For some expr, normally we need to wrap with func() to become expr in go stmt
  But in some case like final expr of block, just return is enough and do not need to wrap func().
  We use type ReturnableExpr for expr of which we can emit directlry return go code.
*/
| EReturnableExpr of ReturnableExpr
and FunCall = {targetFunc: Var; args: []Expr}
and NEPair = {name: string; expr: Expr}
and RecordGen = {fieldsNV: []NEPair; recordType: RecordType}
and Block = {stmts: []Stmt; finalExpr: Expr}
and LazyBlock = {stmts: []Stmt; finalExpr: Expr}
and MatchRule = {pattern: MatchPattern; body: Block}
and MatchExpr = {target: Expr; rules: []MatchRule}
and ReturnableExpr =
| RBlock of Block
| RMatchExpr of MatchExpr
and Stmt =
| SLetVarDef of LetVarDef
| SExprStmt of Expr
and RootStmt =
| RSImport of string
| RSPackage of string
| RSPackageInfo of PackageInfo
| RSDefStmt of DefStmt
| RSMultipleDefs of MultipleDefs
| RSRootFuncDef of RootFuncDef
| RSLetFuncDef of LetFuncDef
and LetFuncDef = {fvar: Var; params: []Var; body:Block}
and RootFuncDef = {tparams:[]string; lfd:LetFuncDef}
and LetVarDef = {lvar: Var; rhs: Expr}
and PackageInfo = {name: string; funcInfo: funcFacDict; typeInfo: extTypeDict}
and RecordDef = {name: string; fields: []NameTypePair}
and UnionDef = {name: string; cases: []NameTypePair}
and DefStmt =
| DRecordDef of RecordDef
| DUnionDef of UnionDef
and MultipleDefs = {defs: []DefStmt}

let NewPackageInfo (name:string) =
  let ffd = newFFD ()
  let etd = newETD ()
  {name=name; funcInfo=ffd; typeInfo=etd}
