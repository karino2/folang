package main

import frt

type GoEval = {goStmt: string; typeArg: FType}
type Var = {name: string; ftype: FType}

// stands for record field access of form: targetName.fieldName
type FieldAccess = {targetName: string; targetType: RecordType; fieldName: string}

type ResolvedTypeParam = {name: string; resolvedType: FType}

/*
Union case matching.
Only support variable match for a while:
| I i -> ...
| Record r -> ...
*/
type MatchPattern = {caseId: string; varName: string}

type Expr =
| GoEval of GoEval
| StringLiteral of string
| IntImm of int
| Unit
| BoolLiteral of bool
| FunCall of FunCall
| FieldAccess of FieldAccess
| Var of Var
| RecordGen of RecordGen
/*
  For some expr, normally we need to wrap with func() to become expr in go stmt
  But in some case like final expr of block, just return is enough and do not need to wrap func().
  We use type ReturnableExpr for expr of which we can emit directlry return go code.
*/
| ReturnableExpr of ReturnableExpr
and FunCall = {targetFunc: Var; args: []Expr; typeParams: []ResolvedTypeParam}
and RecordGen = {fieldNames: []string; fieldValues: []Expr; recordType: FType}
and Block = {stms: []Stmt; finalExpr: Expr; asFunc: bool}
and MatchRule = {pattern: MatchPattern; body: Block}
and MatchExpr = {target: Expr; rules: []MatchRule}
and ReturnableExpr =
| Block of Block
| MatchExpr of MatchExpr
and Stmt =
| Import of string
| Package of string
| LetFuncDef of LetFuncDef
| LetVarDef of LetVarDef
| ExprStmt of Expr
| DefStmt of DefStmt
| MultipleDefs of MultipeDefs
and LetFuncDef = {name: string; params: []Var; body:Block}
and LetVarDef = {name: string; rhs: Expr}
and RecordDef = {name: string; fields: []NameTypePair}
and UnionDef = {name: string; cases: []NameTypePair}
and DefStmt =
| RecordDef of RecordDef
| UnionDef of UnionDef
and MultipeDefs = {defs: []DefStmt}


/*
map, NYI
and PackageInfo = {name: string; funcInfo: map<string, FuncType>; typeInfo: map<string, FExtType>}

| PackageInfo of PackageInfo
*/

let faToType (fa:FieldAccess) =
  let rt = fa.targetType
  let field = frGetField rt fa.fieldName
  field.ftype

let blockReturnType (toT: Expr->FType) (block:Block) =
  toT block.finalExpr

let blockToType (toT: Expr->FType)  (b:Block)=
  let rtype = blockReturnType toT b
  if b.asFunc then
    FFunc {targets=[FUnit; rtype]}
  else
    rtype

let meToType (toT: Expr->FType) (me:MatchExpr) =
  let frule = me.rules |> slice.Head
  toT frule.body

let returnableToType (toT: Expr->FType) (rexpr:ReturnableExpr)  : FType =
  match rexpr with
  | Block b -> blockToType toT b
  | MatchExpr me -> meToType toT me



let ExprToType (expr:Expr) : FType =
  match expr with
  | GoEval ge -> ge.typeArg
  | StringLiteral _ -> FString
  | IntImm _ -> FInt
  | Unit -> FUnit
  | BoolLiteral _ -> FBool
  | FieldAccess fa -> faToType fa
  | Var v -> v.ftype
  | RecordGen rg -> rg.recordType
  | ReturnableExpr re -> returnableToType ExprToType re
  // TODO: below here.
  | FunCall _ -> FUnit

